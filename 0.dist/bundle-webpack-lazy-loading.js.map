{"version":3,"sources":["webpack:///0.dist/bundle-webpack-lazy-loading.js","webpack:///./node_modules/rxjs/operators/merge.js","webpack:///./node_modules/rxjs/observable/concat.js","webpack:///./node_modules/rxjs/add/observable/timer.js","webpack:///./node_modules/rxjs/observable/timer.js","webpack:///./node_modules/rxjs/observable/TimerObservable.js","webpack:///./node_modules/rxjs/util/isNumeric.js","webpack:///./node_modules/rxjs/scheduler/async.js","webpack:///./node_modules/rxjs/scheduler/AsyncAction.js","webpack:///./node_modules/rxjs/scheduler/Action.js","webpack:///./node_modules/rxjs/scheduler/AsyncScheduler.js","webpack:///./node_modules/rxjs/Scheduler.js","webpack:///./node_modules/rxjs/util/isDate.js","webpack:///./node_modules/rxjs/add/observable/forkJoin.js","webpack:///./node_modules/rxjs/add/observable/of.js","webpack:///./node_modules/rxjs/add/operator/take.js","webpack:///./node_modules/rxjs/operator/take.js","webpack:///./node_modules/rxjs/operators/take.js","webpack:///./node_modules/rxjs/add/operator/concat.js","webpack:///./node_modules/rxjs/operator/concat.js","webpack:///./node_modules/rxjs/operators/concat.js","webpack:///./components/rxjs-streams/rxjs-streams.ngfactory.js","webpack:///./app-lazy/lazy-modules/rxjs-streams.module.ts","webpack:///./components/rxjs-streams/rxjs-streams.ts","webpack:///./app-lazy/lazy-modules/rxjs-streams.module.ngfactory.js","webpack:///./node_modules/rxjs/add/operator/map.js","webpack:///./node_modules/rxjs/observable/forkJoin.js","webpack:///./node_modules/rxjs/observable/ForkJoinObservable.js","webpack:///./node_modules/rxjs/add/operator/mergeMap.js","webpack:///./node_modules/rxjs/add/operator/merge.js","webpack:///./node_modules/rxjs/operator/merge.js"],"names":["webpackJsonp","100","module","exports","__webpack_require__","merge","observables","_i","arguments","length","source","lift","call","merge_1","apply","concat","merge_2","mergeStatic","101","isScheduler_1","isScheduler","from_1","from","concatAll_1","concatAll","of_1","of","108","Observable_1","timer_1","Observable","timer","109","TimerObservable_1","TimerObservable","create","110","__extends","this","d","b","__","constructor","p","hasOwnProperty","prototype","Object","isNumeric_1","async_1","isDate_1","_super","dueTime","period","scheduler","isNumeric","Number","async","isDate","now","initialDelay","dispatch","state","index","subscriber","action","next","closed","complete","schedule","_subscribe","_a","111","val","isArray_1","isArray","parseFloat","112","AsyncAction_1","AsyncScheduler_1","AsyncScheduler","AsyncAction","113","root_1","Action_1","work","pending","delay","id","recycleAsyncId","requestAsyncId","root","setInterval","flush","bind","clearInterval","undefined","execute","Error","error","_execute","errored","errorValue","e","unsubscribe","_unsubscribe","actions","indexOf","splice","Action","114","Subscription_1","Subscription","115","Scheduler_1","active","scheduled","push","shift","Scheduler","116","SchedulerAction","Date","117","value","isNaN","118","forkJoin_1","forkJoin","119","120","take_1","take","121","count","122","EmptyObservable_1","EmptyObservable","TakeOperator","Subscriber_1","ArgumentOutOfRangeError_1","total","ArgumentOutOfRangeError","subscribe","TakeSubscriber","destination","_next","Subscriber","123","concat_1","124","concat_2","concatStatic","125","83","__webpack_exports__","View_RxJsStreams_1","_l","core","common","klass","ngClass","stream1","stream2","_ck","_v","context","$implicit","View_RxJsStreams_2","View_RxJsStreams_3","View_RxJsStreams_0","en","$event","ad","_co","component","mergeStreams","concatStreams","forkJoinStreams","flatMapStreams","ngForOf","concatStream","mergeStream","forkJoinStream","flatMappedStreams","msg","View_RxJsStreams_Host_0","RenderType_RxJsStreams","rxjs_streams_RxJsStreams","defineProperty","RxJsStreamsModule","RxJsStreams","_this","flatMap","operand1","res","first","map","r","second","styles_RxJsStreams","encapsulation","styles","data","RxJsStreamsNgFactory","router","RxJsStreamsModuleNgFactory","path","93","map_1","94","ForkJoinObservable_1","ForkJoinObservable","95","subscribeToResult_1","OuterSubscriber_1","sources","resultSelector","pop","ForkJoinSubscriber","completed","haveValues","len","values","Array","i","innerSubscription","subscribeToResult","outerIndex","add","notifyNext","outerValue","innerValue","innerIndex","innerSub","_hasValue","notifyComplete","OuterSubscriber","97","mergeMap_1","mergeMap","98","99"],"mappings":"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","file":"0.dist/bundle-webpack-lazy-loading.js","sourcesContent":["webpackJsonp([0],{\n\n/***/ 100:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar merge_1 = __webpack_require__(36);\nvar merge_2 = __webpack_require__(36);\nexports.mergeStatic = merge_2.merge;\n/* tslint:enable:max-line-length */\n/**\n * Creates an output Observable which concurrently emits all values from every\n * given input Observable.\n *\n * <span class=\"informal\">Flattens multiple Observables together by blending\n * their values into one Observable.</span>\n *\n * <img src=\"./img/merge.png\" width=\"100%\">\n *\n * `merge` subscribes to each given input Observable (either the source or an\n * Observable given as argument), and simply forwards (without doing any\n * transformation) all the values from all the input Observables to the output\n * Observable. The output Observable only completes once all input Observables\n * have completed. Any error delivered by an input Observable will be immediately\n * emitted on the output Observable.\n *\n * @example <caption>Merge together two Observables: 1s interval and clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var timer = Rx.Observable.interval(1000);\n * var clicksOrTimer = clicks.merge(timer);\n * clicksOrTimer.subscribe(x => console.log(x));\n *\n * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var concurrent = 2; // the argument\n * var merged = timer1.merge(timer2, timer3, concurrent);\n * merged.subscribe(x => console.log(x));\n *\n * @see {@link mergeAll}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n *\n * @param {ObservableInput} other An input Observable to merge with the source\n * Observable. More than one input Observables may be given as argument.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @param {Scheduler} [scheduler=null] The IScheduler to use for managing\n * concurrency of input Observables.\n * @return {Observable} An Observable that emits items that are the result of\n * every input Observable.\n * @method merge\n * @owner Observable\n */\nfunction merge() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    return function (source) { return source.lift.call(merge_1.merge.apply(void 0, [source].concat(observables))); };\n}\nexports.merge = merge;\n//# sourceMappingURL=merge.js.map\n\n/***/ }),\n\n/***/ 101:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar isScheduler_1 = __webpack_require__(21);\nvar of_1 = __webpack_require__(38);\nvar from_1 = __webpack_require__(41);\nvar concatAll_1 = __webpack_require__(42);\n/* tslint:enable:max-line-length */\n/**\n * Creates an output Observable which sequentially emits all values from given\n * Observable and then moves on to the next.\n *\n * <span class=\"informal\">Concatenates multiple Observables together by\n * sequentially emitting their values, one Observable after the other.</span>\n *\n * <img src=\"./img/concat.png\" width=\"100%\">\n *\n * `concat` joins multiple Observables together, by subscribing to them one at a time and\n * merging their results into the output Observable. You can pass either an array of\n * Observables, or put them directly as arguments. Passing an empty array will result\n * in Observable that completes immediately.\n *\n * `concat` will subscribe to first input Observable and emit all its values, without\n * changing or affecting them in any way. When that Observable completes, it will\n * subscribe to then next Observable passed and, again, emit its values. This will be\n * repeated, until the operator runs out of Observables. When last input Observable completes,\n * `concat` will complete as well. At any given moment only one Observable passed to operator\n * emits values. If you would like to emit values from passed Observables concurrently, check out\n * {@link merge} instead, especially with optional `concurrent` parameter. As a matter of fact,\n * `concat` is an equivalent of `merge` operator with `concurrent` parameter set to `1`.\n *\n * Note that if some input Observable never completes, `concat` will also never complete\n * and Observables following the one that did not complete will never be subscribed. On the other\n * hand, if some Observable simply completes immediately after it is subscribed, it will be\n * invisible for `concat`, which will just move on to the next Observable.\n *\n * If any Observable in chain errors, instead of passing control to the next Observable,\n * `concat` will error immediately as well. Observables that would be subscribed after\n * the one that emitted error, never will.\n *\n * If you pass to `concat` the same Observable many times, its stream of values\n * will be \"replayed\" on every subscription, which means you can repeat given Observable\n * as many times as you like. If passing the same Observable to `concat` 1000 times becomes tedious,\n * you can always use {@link repeat}.\n *\n * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>\n * var timer = Rx.Observable.interval(1000).take(4);\n * var sequence = Rx.Observable.range(1, 10);\n * var result = Rx.Observable.concat(timer, sequence);\n * result.subscribe(x => console.log(x));\n *\n * // results in:\n * // 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10\n *\n *\n * @example <caption>Concatenate an array of 3 Observables</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var result = Rx.Observable.concat([timer1, timer2, timer3]); // note that array is passed\n * result.subscribe(x => console.log(x));\n *\n * // results in the following:\n * // (Prints to console sequentially)\n * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9\n * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5\n * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9\n *\n *\n * @example <caption>Concatenate the same Observable to repeat it</caption>\n * const timer = Rx.Observable.interval(1000).take(2);\n *\n * Rx.Observable.concat(timer, timer) // concating the same Observable!\n * .subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('...and it is done!')\n * );\n *\n * // Logs:\n * // 0 after 1s\n * // 1 after 2s\n * // 0 after 3s\n * // 1 after 4s\n * // \"...and it is done!\" also after 4s\n *\n * @see {@link concatAll}\n * @see {@link concatMap}\n * @see {@link concatMapTo}\n *\n * @param {ObservableInput} input1 An input Observable to concatenate with others.\n * @param {ObservableInput} input2 An input Observable to concatenate with others.\n * More than one input Observables may be given as argument.\n * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each\n * Observable subscription on.\n * @return {Observable} All values of each passed Observable merged into a\n * single Observable, in order, in serial fashion.\n * @static true\n * @name concat\n * @owner Observable\n */\nfunction concat() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    if (observables.length === 1 || (observables.length === 2 && isScheduler_1.isScheduler(observables[1]))) {\n        return from_1.from(observables[0]);\n    }\n    return concatAll_1.concatAll()(of_1.of.apply(void 0, observables));\n}\nexports.concat = concat;\n//# sourceMappingURL=concat.js.map\n\n/***/ }),\n\n/***/ 108:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(1);\nvar timer_1 = __webpack_require__(109);\nObservable_1.Observable.timer = timer_1.timer;\n//# sourceMappingURL=timer.js.map\n\n/***/ }),\n\n/***/ 109:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar TimerObservable_1 = __webpack_require__(110);\nexports.timer = TimerObservable_1.TimerObservable.create;\n//# sourceMappingURL=timer.js.map\n\n/***/ }),\n\n/***/ 110:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar isNumeric_1 = __webpack_require__(111);\nvar Observable_1 = __webpack_require__(1);\nvar async_1 = __webpack_require__(112);\nvar isScheduler_1 = __webpack_require__(21);\nvar isDate_1 = __webpack_require__(117);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar TimerObservable = (function (_super) {\n    __extends(TimerObservable, _super);\n    function TimerObservable(dueTime, period, scheduler) {\n        if (dueTime === void 0) { dueTime = 0; }\n        _super.call(this);\n        this.period = -1;\n        this.dueTime = 0;\n        if (isNumeric_1.isNumeric(period)) {\n            this.period = Number(period) < 1 && 1 || Number(period);\n        }\n        else if (isScheduler_1.isScheduler(period)) {\n            scheduler = period;\n        }\n        if (!isScheduler_1.isScheduler(scheduler)) {\n            scheduler = async_1.async;\n        }\n        this.scheduler = scheduler;\n        this.dueTime = isDate_1.isDate(dueTime) ?\n            (+dueTime - this.scheduler.now()) :\n            dueTime;\n    }\n    /**\n     * Creates an Observable that starts emitting after an `initialDelay` and\n     * emits ever increasing numbers after each `period` of time thereafter.\n     *\n     * <span class=\"informal\">Its like {@link interval}, but you can specify when\n     * should the emissions start.</span>\n     *\n     * <img src=\"./img/timer.png\" width=\"100%\">\n     *\n     * `timer` returns an Observable that emits an infinite sequence of ascending\n     * integers, with a constant interval of time, `period` of your choosing\n     * between those emissions. The first emission happens after the specified\n     * `initialDelay`. The initial delay may be a {@link Date}. By default, this\n     * operator uses the `async` IScheduler to provide a notion of time, but you\n     * may pass any IScheduler to it. If `period` is not specified, the output\n     * Observable emits only one value, `0`. Otherwise, it emits an infinite\n     * sequence.\n     *\n     * @example <caption>Emits ascending numbers, one every second (1000ms), starting after 3 seconds</caption>\n     * var numbers = Rx.Observable.timer(3000, 1000);\n     * numbers.subscribe(x => console.log(x));\n     *\n     * @example <caption>Emits one number after five seconds</caption>\n     * var numbers = Rx.Observable.timer(5000);\n     * numbers.subscribe(x => console.log(x));\n     *\n     * @see {@link interval}\n     * @see {@link delay}\n     *\n     * @param {number|Date} initialDelay The initial delay time to wait before\n     * emitting the first value of `0`.\n     * @param {number} [period] The period of time between emissions of the\n     * subsequent numbers.\n     * @param {Scheduler} [scheduler=async] The IScheduler to use for scheduling\n     * the emission of values, and providing a notion of \"time\".\n     * @return {Observable} An Observable that emits a `0` after the\n     * `initialDelay` and ever increasing numbers after each `period` of time\n     * thereafter.\n     * @static true\n     * @name timer\n     * @owner Observable\n     */\n    TimerObservable.create = function (initialDelay, period, scheduler) {\n        if (initialDelay === void 0) { initialDelay = 0; }\n        return new TimerObservable(initialDelay, period, scheduler);\n    };\n    TimerObservable.dispatch = function (state) {\n        var index = state.index, period = state.period, subscriber = state.subscriber;\n        var action = this;\n        subscriber.next(index);\n        if (subscriber.closed) {\n            return;\n        }\n        else if (period === -1) {\n            return subscriber.complete();\n        }\n        state.index = index + 1;\n        action.schedule(state, period);\n    };\n    TimerObservable.prototype._subscribe = function (subscriber) {\n        var index = 0;\n        var _a = this, period = _a.period, dueTime = _a.dueTime, scheduler = _a.scheduler;\n        return scheduler.schedule(TimerObservable.dispatch, dueTime, {\n            index: index, period: period, subscriber: subscriber\n        });\n    };\n    return TimerObservable;\n}(Observable_1.Observable));\nexports.TimerObservable = TimerObservable;\n//# sourceMappingURL=TimerObservable.js.map\n\n/***/ }),\n\n/***/ 111:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar isArray_1 = __webpack_require__(18);\nfunction isNumeric(val) {\n    // parseFloat NaNs numeric-cast false positives (null|true|false|\"\")\n    // ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n    // subtraction forces infinities to NaN\n    // adding 1 corrects loss of precision from parseFloat (#15100)\n    return !isArray_1.isArray(val) && (val - parseFloat(val) + 1) >= 0;\n}\nexports.isNumeric = isNumeric;\n;\n//# sourceMappingURL=isNumeric.js.map\n\n/***/ }),\n\n/***/ 112:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar AsyncAction_1 = __webpack_require__(113);\nvar AsyncScheduler_1 = __webpack_require__(115);\n/**\n *\n * Async Scheduler\n *\n * <span class=\"informal\">Schedule task as if you used setTimeout(task, duration)</span>\n *\n * `async` scheduler schedules tasks asynchronously, by putting them on the JavaScript\n * event loop queue. It is best used to delay tasks in time or to schedule tasks repeating\n * in intervals.\n *\n * If you just want to \"defer\" task, that is to perform it right after currently\n * executing synchronous code ends (commonly achieved by `setTimeout(deferredTask, 0)`),\n * better choice will be the {@link asap} scheduler.\n *\n * @example <caption>Use async scheduler to delay task</caption>\n * const task = () => console.log('it works!');\n *\n * Rx.Scheduler.async.schedule(task, 2000);\n *\n * // After 2 seconds logs:\n * // \"it works!\"\n *\n *\n * @example <caption>Use async scheduler to repeat task in intervals</caption>\n * function task(state) {\n *   console.log(state);\n *   this.schedule(state + 1, 1000); // `this` references currently executing Action,\n *                                   // which we reschedule with new state and delay\n * }\n *\n * Rx.Scheduler.async.schedule(task, 3000, 0);\n *\n * // Logs:\n * // 0 after 3s\n * // 1 after 4s\n * // 2 after 5s\n * // 3 after 6s\n *\n * @static true\n * @name async\n * @owner Scheduler\n */\nexports.async = new AsyncScheduler_1.AsyncScheduler(AsyncAction_1.AsyncAction);\n//# sourceMappingURL=async.js.map\n\n/***/ }),\n\n/***/ 113:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar root_1 = __webpack_require__(2);\nvar Action_1 = __webpack_require__(114);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar AsyncAction = (function (_super) {\n    __extends(AsyncAction, _super);\n    function AsyncAction(scheduler, work) {\n        _super.call(this, scheduler, work);\n        this.scheduler = scheduler;\n        this.work = work;\n        this.pending = false;\n    }\n    AsyncAction.prototype.schedule = function (state, delay) {\n        if (delay === void 0) { delay = 0; }\n        if (this.closed) {\n            return this;\n        }\n        // Always replace the current state with the new state.\n        this.state = state;\n        // Set the pending flag indicating that this action has been scheduled, or\n        // has recursively rescheduled itself.\n        this.pending = true;\n        var id = this.id;\n        var scheduler = this.scheduler;\n        //\n        // Important implementation note:\n        //\n        // Actions only execute once by default, unless rescheduled from within the\n        // scheduled callback. This allows us to implement single and repeat\n        // actions via the same code path, without adding API surface area, as well\n        // as mimic traditional recursion but across asynchronous boundaries.\n        //\n        // However, JS runtimes and timers distinguish between intervals achieved by\n        // serial `setTimeout` calls vs. a single `setInterval` call. An interval of\n        // serial `setTimeout` calls can be individually delayed, which delays\n        // scheduling the next `setTimeout`, and so on. `setInterval` attempts to\n        // guarantee the interval callback will be invoked more precisely to the\n        // interval period, regardless of load.\n        //\n        // Therefore, we use `setInterval` to schedule single and repeat actions.\n        // If the action reschedules itself with the same delay, the interval is not\n        // canceled. If the action doesn't reschedule, or reschedules with a\n        // different delay, the interval will be canceled after scheduled callback\n        // execution.\n        //\n        if (id != null) {\n            this.id = this.recycleAsyncId(scheduler, id, delay);\n        }\n        this.delay = delay;\n        // If this action has already an async Id, don't request a new one.\n        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);\n        return this;\n    };\n    AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) { delay = 0; }\n        return root_1.root.setInterval(scheduler.flush.bind(scheduler, this), delay);\n    };\n    AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) { delay = 0; }\n        // If this action is rescheduled with the same delay time, don't clear the interval id.\n        if (delay !== null && this.delay === delay && this.pending === false) {\n            return id;\n        }\n        // Otherwise, if the action's delay time is different from the current delay,\n        // or the action has been rescheduled before it's executed, clear the interval id\n        return root_1.root.clearInterval(id) && undefined || undefined;\n    };\n    /**\n     * Immediately executes this action and the `work` it contains.\n     * @return {any}\n     */\n    AsyncAction.prototype.execute = function (state, delay) {\n        if (this.closed) {\n            return new Error('executing a cancelled action');\n        }\n        this.pending = false;\n        var error = this._execute(state, delay);\n        if (error) {\n            return error;\n        }\n        else if (this.pending === false && this.id != null) {\n            // Dequeue if the action didn't reschedule itself. Don't call\n            // unsubscribe(), because the action could reschedule later.\n            // For example:\n            // ```\n            // scheduler.schedule(function doWork(counter) {\n            //   /* ... I'm a busy worker bee ... */\n            //   var originalAction = this;\n            //   /* wait 100ms before rescheduling the action */\n            //   setTimeout(function () {\n            //     originalAction.schedule(counter + 1);\n            //   }, 100);\n            // }, 1000);\n            // ```\n            this.id = this.recycleAsyncId(this.scheduler, this.id, null);\n        }\n    };\n    AsyncAction.prototype._execute = function (state, delay) {\n        var errored = false;\n        var errorValue = undefined;\n        try {\n            this.work(state);\n        }\n        catch (e) {\n            errored = true;\n            errorValue = !!e && e || new Error(e);\n        }\n        if (errored) {\n            this.unsubscribe();\n            return errorValue;\n        }\n    };\n    AsyncAction.prototype._unsubscribe = function () {\n        var id = this.id;\n        var scheduler = this.scheduler;\n        var actions = scheduler.actions;\n        var index = actions.indexOf(this);\n        this.work = null;\n        this.state = null;\n        this.pending = false;\n        this.scheduler = null;\n        if (index !== -1) {\n            actions.splice(index, 1);\n        }\n        if (id != null) {\n            this.id = this.recycleAsyncId(scheduler, id, null);\n        }\n        this.delay = null;\n    };\n    return AsyncAction;\n}(Action_1.Action));\nexports.AsyncAction = AsyncAction;\n//# sourceMappingURL=AsyncAction.js.map\n\n/***/ }),\n\n/***/ 114:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscription_1 = __webpack_require__(7);\n/**\n * A unit of work to be executed in a {@link Scheduler}. An action is typically\n * created from within a Scheduler and an RxJS user does not need to concern\n * themselves about creating and manipulating an Action.\n *\n * ```ts\n * class Action<T> extends Subscription {\n *   new (scheduler: Scheduler, work: (state?: T) => void);\n *   schedule(state?: T, delay: number = 0): Subscription;\n * }\n * ```\n *\n * @class Action<T>\n */\nvar Action = (function (_super) {\n    __extends(Action, _super);\n    function Action(scheduler, work) {\n        _super.call(this);\n    }\n    /**\n     * Schedules this action on its parent Scheduler for execution. May be passed\n     * some context object, `state`. May happen at some point in the future,\n     * according to the `delay` parameter, if specified.\n     * @param {T} [state] Some contextual data that the `work` function uses when\n     * called by the Scheduler.\n     * @param {number} [delay] Time to wait before executing the work, where the\n     * time unit is implicit and defined by the Scheduler.\n     * @return {void}\n     */\n    Action.prototype.schedule = function (state, delay) {\n        if (delay === void 0) { delay = 0; }\n        return this;\n    };\n    return Action;\n}(Subscription_1.Subscription));\nexports.Action = Action;\n//# sourceMappingURL=Action.js.map\n\n/***/ }),\n\n/***/ 115:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Scheduler_1 = __webpack_require__(116);\nvar AsyncScheduler = (function (_super) {\n    __extends(AsyncScheduler, _super);\n    function AsyncScheduler() {\n        _super.apply(this, arguments);\n        this.actions = [];\n        /**\n         * A flag to indicate whether the Scheduler is currently executing a batch of\n         * queued actions.\n         * @type {boolean}\n         */\n        this.active = false;\n        /**\n         * An internal ID used to track the latest asynchronous task such as those\n         * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and\n         * others.\n         * @type {any}\n         */\n        this.scheduled = undefined;\n    }\n    AsyncScheduler.prototype.flush = function (action) {\n        var actions = this.actions;\n        if (this.active) {\n            actions.push(action);\n            return;\n        }\n        var error;\n        this.active = true;\n        do {\n            if (error = action.execute(action.state, action.delay)) {\n                break;\n            }\n        } while (action = actions.shift()); // exhaust the scheduler queue\n        this.active = false;\n        if (error) {\n            while (action = actions.shift()) {\n                action.unsubscribe();\n            }\n            throw error;\n        }\n    };\n    return AsyncScheduler;\n}(Scheduler_1.Scheduler));\nexports.AsyncScheduler = AsyncScheduler;\n//# sourceMappingURL=AsyncScheduler.js.map\n\n/***/ }),\n\n/***/ 116:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * An execution context and a data structure to order tasks and schedule their\n * execution. Provides a notion of (potentially virtual) time, through the\n * `now()` getter method.\n *\n * Each unit of work in a Scheduler is called an {@link Action}.\n *\n * ```ts\n * class Scheduler {\n *   now(): number;\n *   schedule(work, delay?, state?): Subscription;\n * }\n * ```\n *\n * @class Scheduler\n */\nvar Scheduler = (function () {\n    function Scheduler(SchedulerAction, now) {\n        if (now === void 0) { now = Scheduler.now; }\n        this.SchedulerAction = SchedulerAction;\n        this.now = now;\n    }\n    /**\n     * Schedules a function, `work`, for execution. May happen at some point in\n     * the future, according to the `delay` parameter, if specified. May be passed\n     * some context object, `state`, which will be passed to the `work` function.\n     *\n     * The given arguments will be processed an stored as an Action object in a\n     * queue of actions.\n     *\n     * @param {function(state: ?T): ?Subscription} work A function representing a\n     * task, or some unit of work to be executed by the Scheduler.\n     * @param {number} [delay] Time to wait before executing the work, where the\n     * time unit is implicit and defined by the Scheduler itself.\n     * @param {T} [state] Some contextual data that the `work` function uses when\n     * called by the Scheduler.\n     * @return {Subscription} A subscription in order to be able to unsubscribe\n     * the scheduled work.\n     */\n    Scheduler.prototype.schedule = function (work, delay, state) {\n        if (delay === void 0) { delay = 0; }\n        return new this.SchedulerAction(this, work).schedule(state, delay);\n    };\n    Scheduler.now = Date.now ? Date.now : function () { return +new Date(); };\n    return Scheduler;\n}());\nexports.Scheduler = Scheduler;\n//# sourceMappingURL=Scheduler.js.map\n\n/***/ }),\n\n/***/ 117:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nfunction isDate(value) {\n    return value instanceof Date && !isNaN(+value);\n}\nexports.isDate = isDate;\n//# sourceMappingURL=isDate.js.map\n\n/***/ }),\n\n/***/ 118:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(1);\nvar forkJoin_1 = __webpack_require__(94);\nObservable_1.Observable.forkJoin = forkJoin_1.forkJoin;\n//# sourceMappingURL=forkJoin.js.map\n\n/***/ }),\n\n/***/ 119:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(1);\nvar of_1 = __webpack_require__(38);\nObservable_1.Observable.of = of_1.of;\n//# sourceMappingURL=of.js.map\n\n/***/ }),\n\n/***/ 120:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(1);\nvar take_1 = __webpack_require__(121);\nObservable_1.Observable.prototype.take = take_1.take;\n//# sourceMappingURL=take.js.map\n\n/***/ }),\n\n/***/ 121:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar take_1 = __webpack_require__(122);\n/**\n * Emits only the first `count` values emitted by the source Observable.\n *\n * <span class=\"informal\">Takes the first `count` values from the source, then\n * completes.</span>\n *\n * <img src=\"./img/take.png\" width=\"100%\">\n *\n * `take` returns an Observable that emits only the first `count` values emitted\n * by the source Observable. If the source emits fewer than `count` values then\n * all of its values are emitted. After that, it completes, regardless if the\n * source completes.\n *\n * @example <caption>Take the first 5 seconds of an infinite 1-second interval Observable</caption>\n * var interval = Rx.Observable.interval(1000);\n * var five = interval.take(5);\n * five.subscribe(x => console.log(x));\n *\n * @see {@link takeLast}\n * @see {@link takeUntil}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @throws {ArgumentOutOfRangeError} When using `take(i)`, it delivers an\n * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.\n *\n * @param {number} count The maximum number of `next` values to emit.\n * @return {Observable<T>} An Observable that emits only the first `count`\n * values emitted by the source Observable, or all of the values from the source\n * if the source emits fewer than `count` values.\n * @method take\n * @owner Observable\n */\nfunction take(count) {\n    return take_1.take(count)(this);\n}\nexports.take = take;\n//# sourceMappingURL=take.js.map\n\n/***/ }),\n\n/***/ 122:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(0);\nvar ArgumentOutOfRangeError_1 = __webpack_require__(43);\nvar EmptyObservable_1 = __webpack_require__(8);\n/**\n * Emits only the first `count` values emitted by the source Observable.\n *\n * <span class=\"informal\">Takes the first `count` values from the source, then\n * completes.</span>\n *\n * <img src=\"./img/take.png\" width=\"100%\">\n *\n * `take` returns an Observable that emits only the first `count` values emitted\n * by the source Observable. If the source emits fewer than `count` values then\n * all of its values are emitted. After that, it completes, regardless if the\n * source completes.\n *\n * @example <caption>Take the first 5 seconds of an infinite 1-second interval Observable</caption>\n * var interval = Rx.Observable.interval(1000);\n * var five = interval.take(5);\n * five.subscribe(x => console.log(x));\n *\n * @see {@link takeLast}\n * @see {@link takeUntil}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @throws {ArgumentOutOfRangeError} When using `take(i)`, it delivers an\n * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.\n *\n * @param {number} count The maximum number of `next` values to emit.\n * @return {Observable<T>} An Observable that emits only the first `count`\n * values emitted by the source Observable, or all of the values from the source\n * if the source emits fewer than `count` values.\n * @method take\n * @owner Observable\n */\nfunction take(count) {\n    return function (source) {\n        if (count === 0) {\n            return new EmptyObservable_1.EmptyObservable();\n        }\n        else {\n            return source.lift(new TakeOperator(count));\n        }\n    };\n}\nexports.take = take;\nvar TakeOperator = (function () {\n    function TakeOperator(total) {\n        this.total = total;\n        if (this.total < 0) {\n            throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;\n        }\n    }\n    TakeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new TakeSubscriber(subscriber, this.total));\n    };\n    return TakeOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar TakeSubscriber = (function (_super) {\n    __extends(TakeSubscriber, _super);\n    function TakeSubscriber(destination, total) {\n        _super.call(this, destination);\n        this.total = total;\n        this.count = 0;\n    }\n    TakeSubscriber.prototype._next = function (value) {\n        var total = this.total;\n        var count = ++this.count;\n        if (count <= total) {\n            this.destination.next(value);\n            if (count === total) {\n                this.destination.complete();\n                this.unsubscribe();\n            }\n        }\n    };\n    return TakeSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=take.js.map\n\n/***/ }),\n\n/***/ 123:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(1);\nvar concat_1 = __webpack_require__(124);\nObservable_1.Observable.prototype.concat = concat_1.concat;\n//# sourceMappingURL=concat.js.map\n\n/***/ }),\n\n/***/ 124:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar concat_1 = __webpack_require__(125);\nvar concat_2 = __webpack_require__(101);\nexports.concatStatic = concat_2.concat;\n/* tslint:enable:max-line-length */\n/**\n * Creates an output Observable which sequentially emits all values from every\n * given input Observable after the current Observable.\n *\n * <span class=\"informal\">Concatenates multiple Observables together by\n * sequentially emitting their values, one Observable after the other.</span>\n *\n * <img src=\"./img/concat.png\" width=\"100%\">\n *\n * Joins this Observable with multiple other Observables by subscribing to them\n * one at a time, starting with the source, and merging their results into the\n * output Observable. Will wait for each Observable to complete before moving\n * on to the next.\n *\n * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>\n * var timer = Rx.Observable.interval(1000).take(4);\n * var sequence = Rx.Observable.range(1, 10);\n * var result = timer.concat(sequence);\n * result.subscribe(x => console.log(x));\n *\n * // results in:\n * // 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10\n *\n * @example <caption>Concatenate 3 Observables</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var result = timer1.concat(timer2, timer3);\n * result.subscribe(x => console.log(x));\n *\n * // results in the following:\n * // (Prints to console sequentially)\n * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9\n * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5\n * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9\n *\n * @see {@link concatAll}\n * @see {@link concatMap}\n * @see {@link concatMapTo}\n *\n * @param {ObservableInput} other An input Observable to concatenate after the source\n * Observable. More than one input Observables may be given as argument.\n * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each\n * Observable subscription on.\n * @return {Observable} All values of each passed Observable merged into a\n * single Observable, in order, in serial fashion.\n * @method concat\n * @owner Observable\n */\nfunction concat() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    return concat_1.concat.apply(void 0, observables)(this);\n}\nexports.concat = concat;\n//# sourceMappingURL=concat.js.map\n\n/***/ }),\n\n/***/ 125:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar concat_1 = __webpack_require__(101);\nvar concat_2 = __webpack_require__(101);\nexports.concatStatic = concat_2.concat;\n/* tslint:enable:max-line-length */\n/**\n * Creates an output Observable which sequentially emits all values from every\n * given input Observable after the current Observable.\n *\n * <span class=\"informal\">Concatenates multiple Observables together by\n * sequentially emitting their values, one Observable after the other.</span>\n *\n * <img src=\"./img/concat.png\" width=\"100%\">\n *\n * Joins this Observable with multiple other Observables by subscribing to them\n * one at a time, starting with the source, and merging their results into the\n * output Observable. Will wait for each Observable to complete before moving\n * on to the next.\n *\n * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>\n * var timer = Rx.Observable.interval(1000).take(4);\n * var sequence = Rx.Observable.range(1, 10);\n * var result = timer.concat(sequence);\n * result.subscribe(x => console.log(x));\n *\n * // results in:\n * // 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10\n *\n * @example <caption>Concatenate 3 Observables</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var result = timer1.concat(timer2, timer3);\n * result.subscribe(x => console.log(x));\n *\n * // results in the following:\n * // (Prints to console sequentially)\n * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9\n * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5\n * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9\n *\n * @see {@link concatAll}\n * @see {@link concatMap}\n * @see {@link concatMapTo}\n *\n * @param {ObservableInput} other An input Observable to concatenate after the source\n * Observable. More than one input Observables may be given as argument.\n * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each\n * Observable subscription on.\n * @return {Observable} All values of each passed Observable merged into a\n * single Observable, in order, in serial fashion.\n * @method concat\n * @owner Observable\n */\nfunction concat() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    return function (source) { return source.lift.call(concat_1.concat.apply(void 0, [source].concat(observables))); };\n}\nexports.concat = concat;\n//# sourceMappingURL=concat.js.map\n\n/***/ }),\n\n/***/ 83:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n\n// EXTERNAL MODULE: ./node_modules/@angular/core/esm5/core.js\nvar core = __webpack_require__(3);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/add/operator/map.js\nvar map = __webpack_require__(93);\nvar map_default = /*#__PURE__*/__webpack_require__.n(map);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/add/operator/mergeMap.js\nvar mergeMap = __webpack_require__(97);\nvar mergeMap_default = /*#__PURE__*/__webpack_require__.n(mergeMap);\n\n// CONCATENATED MODULE: ./app-lazy/lazy-modules/rxjs-streams.module.ts\n\n\nvar RxJsStreamsModule = (function () {\n    function RxJsStreamsModule() {\n    }\n    return RxJsStreamsModule;\n}());\n\n\n// EXTERNAL MODULE: ./node_modules/@angular/common/esm5/common.js\nvar common = __webpack_require__(4);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/Observable.js\nvar Observable = __webpack_require__(1);\nvar Observable_default = /*#__PURE__*/__webpack_require__.n(Observable);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/add/observable/timer.js\nvar timer = __webpack_require__(108);\nvar timer_default = /*#__PURE__*/__webpack_require__.n(timer);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/add/observable/forkJoin.js\nvar forkJoin = __webpack_require__(118);\nvar forkJoin_default = /*#__PURE__*/__webpack_require__.n(forkJoin);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/add/observable/of.js\nvar of = __webpack_require__(119);\nvar of_default = /*#__PURE__*/__webpack_require__.n(of);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/add/operator/take.js\nvar take = __webpack_require__(120);\nvar take_default = /*#__PURE__*/__webpack_require__.n(take);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/add/operator/merge.js\nvar merge = __webpack_require__(98);\nvar merge_default = /*#__PURE__*/__webpack_require__.n(merge);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/add/operator/concat.js\nvar concat = __webpack_require__(123);\nvar concat_default = /*#__PURE__*/__webpack_require__.n(concat);\n\n// CONCATENATED MODULE: ./components/rxjs-streams/rxjs-streams.ts\n\n\n\n\n\n\n\nvar rxjs_streams_RxJsStreams = (function () {\n    function RxJsStreams() {\n        this.concatStream = [];\n        this.mergeStream = [];\n        this.forkJoinStream = [];\n        this.flatMappedStreams = {};\n    }\n    RxJsStreams.prototype.flatMapStreams = function () {\n        var _this = this;\n        var first = Observable[\"Observable\"].of(10);\n        first.flatMap(function (operand1) {\n            return Observable[\"Observable\"].of(operand1 + 10);\n        })\n            .subscribe(function (res) { return _this.flatMappedStreams = { msg: '10 + 10 = ' + res }; });\n    };\n    RxJsStreams.prototype.concatStreams = function () {\n        var _this = this;\n        var first = Observable[\"Observable\"].timer(10, 500).map(function (r) {\n            return { source: 1, value: r };\n        }).take(4);\n        var second = Observable[\"Observable\"].timer(10, 500).map(function (r) {\n            return { source: 2, value: r };\n        }).take(4);\n        first.concat(second).subscribe(function (res) { return _this.concatStream.push(res); });\n    };\n    RxJsStreams.prototype.mergeStreams = function () {\n        var _this = this;\n        var first = Observable[\"Observable\"].timer(10, 500).map(function (r) {\n            return { source: 1, value: r };\n        }).take(4);\n        var second = Observable[\"Observable\"].timer(10, 500).map(function (r) {\n            return { source: 2, value: r };\n        }).take(4);\n        first.merge(second).subscribe(function (res) { return _this.mergeStream.push(res); });\n    };\n    RxJsStreams.prototype.forkJoinStreams = function () {\n        var _this = this;\n        var first = Observable[\"Observable\"].of({ source: 1, value: 1 });\n        var second = Observable[\"Observable\"].of({ source: 2, value: 1 });\n        Observable[\"Observable\"].forkJoin(first, second)\n            .subscribe(function (res) { return _this.forkJoinStream = res; });\n    };\n    return RxJsStreams;\n}());\n\n\n// CONCATENATED MODULE: ./components/rxjs-streams/rxjs-streams.ngfactory.js\n\n\n\nvar styles_RxJsStreams = [];\nvar RenderType_RxJsStreams = core[\"_13\" /* crt */]({ encapsulation: 2, styles: styles_RxJsStreams, data: {} });\n\nfunction View_RxJsStreams_1(_l) { return core[\"_37\" /* vid */](0, [(_l()(), core[\"_15\" /* eld */](0, 0, null, null, 4, \"div\", [], null, null, null, null, null)), (_l()(), core[\"_15\" /* eld */](1, 0, null, null, 3, \"div\", [[\"class\", \"floatLeft\"]], null, null, null, null, null)), core[\"_14\" /* did */](2, 278528, null, 0, common[\"i\" /* NgClass */], [core[\"y\" /* IterableDiffers */], core[\"z\" /* KeyValueDiffers */], core[\"n\" /* ElementRef */], core[\"M\" /* Renderer2 */]], { klass: [0, \"klass\"], ngClass: [1, \"ngClass\"] }, null), core[\"_31\" /* pod */](3, { stream1: 0, stream2: 1 }), (_l()(), core[\"_35\" /* ted */](4, null, [\"\", \"\"]))], function (_ck, _v) { var currVal_0 = \"floatLeft\"; var currVal_1 = _ck(_v, 3, 0, (_v.context.$implicit.source === 1), (_v.context.$implicit.source === 2)); _ck(_v, 2, 0, currVal_0, currVal_1); }, function (_ck, _v) { var currVal_2 = _v.context.$implicit.value; _ck(_v, 4, 0, currVal_2); }); }\nfunction View_RxJsStreams_2(_l) { return core[\"_37\" /* vid */](0, [(_l()(), core[\"_15\" /* eld */](0, 0, null, null, 4, \"div\", [], null, null, null, null, null)), (_l()(), core[\"_15\" /* eld */](1, 0, null, null, 3, \"div\", [[\"class\", \"floatLeft\"]], null, null, null, null, null)), core[\"_14\" /* did */](2, 278528, null, 0, common[\"i\" /* NgClass */], [core[\"y\" /* IterableDiffers */], core[\"z\" /* KeyValueDiffers */], core[\"n\" /* ElementRef */], core[\"M\" /* Renderer2 */]], { klass: [0, \"klass\"], ngClass: [1, \"ngClass\"] }, null), core[\"_31\" /* pod */](3, { stream1: 0, stream2: 1 }), (_l()(), core[\"_35\" /* ted */](4, null, [\"\", \"\"]))], function (_ck, _v) { var currVal_0 = \"floatLeft\"; var currVal_1 = _ck(_v, 3, 0, (_v.context.$implicit.source === 1), (_v.context.$implicit.source === 2)); _ck(_v, 2, 0, currVal_0, currVal_1); }, function (_ck, _v) { var currVal_2 = _v.context.$implicit.value; _ck(_v, 4, 0, currVal_2); }); }\nfunction View_RxJsStreams_3(_l) { return core[\"_37\" /* vid */](0, [(_l()(), core[\"_15\" /* eld */](0, 0, null, null, 4, \"div\", [], null, null, null, null, null)), (_l()(), core[\"_15\" /* eld */](1, 0, null, null, 3, \"div\", [], null, null, null, null, null)), core[\"_14\" /* did */](2, 278528, null, 0, common[\"i\" /* NgClass */], [core[\"y\" /* IterableDiffers */], core[\"z\" /* KeyValueDiffers */], core[\"n\" /* ElementRef */], core[\"M\" /* Renderer2 */]], { ngClass: [0, \"ngClass\"] }, null), core[\"_31\" /* pod */](3, { stream1: 0, stream2: 1 }), (_l()(), core[\"_35\" /* ted */](4, null, [\"\", \"\"]))], function (_ck, _v) { var currVal_0 = _ck(_v, 3, 0, (_v.context.$implicit.source === 1), (_v.context.$implicit.source === 2)); _ck(_v, 2, 0, currVal_0); }, function (_ck, _v) { var currVal_1 = _v.context.$implicit.value; _ck(_v, 4, 0, currVal_1); }); }\nfunction View_RxJsStreams_0(_l) { return core[\"_37\" /* vid */](0, [(_l()(), core[\"_15\" /* eld */](0, 0, null, null, 1, \"div\", [[\"class\", \"stream1\"]], null, null, null, null, null)), (_l()(), core[\"_35\" /* ted */](-1, null, [\"Stream1\"])), (_l()(), core[\"_15\" /* eld */](2, 0, null, null, 1, \"div\", [[\"class\", \"stream2\"]], null, null, null, null, null)), (_l()(), core[\"_35\" /* ted */](-1, null, [\"Stream2\"])), (_l()(), core[\"_15\" /* eld */](4, 0, null, null, 0, \"br\", [], null, null, null, null, null)), (_l()(), core[\"_15\" /* eld */](5, 0, null, null, 1, \"button\", [], null, [[null, \"click\"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if ((\"click\" === en)) {\n        var pd_0 = (_co.mergeStreams() !== false);\n        ad = (pd_0 && ad);\n    } return ad; }, null, null)), (_l()(), core[\"_35\" /* ted */](-1, null, [\"Merge Streams\"])), (_l()(), core[\"_15\" /* eld */](7, 0, null, null, 1, \"button\", [], null, [[null, \"click\"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if ((\"click\" === en)) {\n        var pd_0 = (_co.concatStreams() !== false);\n        ad = (pd_0 && ad);\n    } return ad; }, null, null)), (_l()(), core[\"_35\" /* ted */](-1, null, [\"Concat Streams\"])), (_l()(), core[\"_15\" /* eld */](9, 0, null, null, 1, \"button\", [], null, [[null, \"click\"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if ((\"click\" === en)) {\n        var pd_0 = (_co.forkJoinStreams() !== false);\n        ad = (pd_0 && ad);\n    } return ad; }, null, null)), (_l()(), core[\"_35\" /* ted */](-1, null, [\"ForkJoin Streams\"])), (_l()(), core[\"_15\" /* eld */](11, 0, null, null, 1, \"button\", [], null, [[null, \"click\"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if ((\"click\" === en)) {\n        var pd_0 = (_co.flatMapStreams() !== false);\n        ad = (pd_0 && ad);\n    } return ad; }, null, null)), (_l()(), core[\"_35\" /* ted */](-1, null, [\"FlatMap Streams\"])), (_l()(), core[\"_15\" /* eld */](13, 0, null, null, 4, \"div\", [[\"class\", \"stream-section\"]], null, null, null, null, null)), (_l()(), core[\"_15\" /* eld */](14, 0, null, null, 1, \"h4\", [], null, null, null, null, null)), (_l()(), core[\"_35\" /* ted */](-1, null, [\"Concatenated Streams\"])), (_l()(), core[\"_10\" /* and */](16777216, null, null, 1, null, View_RxJsStreams_1)), core[\"_14\" /* did */](17, 802816, null, 0, common[\"j\" /* NgForOf */], [core[\"Y\" /* ViewContainerRef */], core[\"V\" /* TemplateRef */], core[\"y\" /* IterableDiffers */]], { ngForOf: [0, \"ngForOf\"] }, null), (_l()(), core[\"_15\" /* eld */](18, 0, null, null, 4, \"div\", [[\"class\", \"stream-section\"]], null, null, null, null, null)), (_l()(), core[\"_15\" /* eld */](19, 0, null, null, 1, \"h4\", [], null, null, null, null, null)), (_l()(), core[\"_35\" /* ted */](-1, null, [\"Merged Streams\"])), (_l()(), core[\"_10\" /* and */](16777216, null, null, 1, null, View_RxJsStreams_2)), core[\"_14\" /* did */](22, 802816, null, 0, common[\"j\" /* NgForOf */], [core[\"Y\" /* ViewContainerRef */], core[\"V\" /* TemplateRef */], core[\"y\" /* IterableDiffers */]], { ngForOf: [0, \"ngForOf\"] }, null), (_l()(), core[\"_15\" /* eld */](23, 0, null, null, 4, \"div\", [[\"class\", \"stream-section\"]], null, null, null, null, null)), (_l()(), core[\"_15\" /* eld */](24, 0, null, null, 1, \"h4\", [], null, null, null, null, null)), (_l()(), core[\"_35\" /* ted */](-1, null, [\"ForkJoined Streams\"])), (_l()(), core[\"_10\" /* and */](16777216, null, null, 1, null, View_RxJsStreams_3)), core[\"_14\" /* did */](27, 802816, null, 0, common[\"j\" /* NgForOf */], [core[\"Y\" /* ViewContainerRef */], core[\"V\" /* TemplateRef */], core[\"y\" /* IterableDiffers */]], { ngForOf: [0, \"ngForOf\"] }, null), (_l()(), core[\"_15\" /* eld */](28, 0, null, null, 0, \"br\", [], null, null, null, null, null)), (_l()(), core[\"_15\" /* eld */](29, 0, null, null, 4, \"div\", [], null, null, null, null, null)), (_l()(), core[\"_15\" /* eld */](30, 0, null, null, 1, \"h4\", [], null, null, null, null, null)), (_l()(), core[\"_35\" /* ted */](-1, null, [\"Flatmapped Streams\"])), (_l()(), core[\"_15\" /* eld */](32, 0, null, null, 1, \"div\", [], null, null, null, null, null)), (_l()(), core[\"_35\" /* ted */](33, null, [\"\", \"\"]))], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.concatStream; _ck(_v, 17, 0, currVal_0); var currVal_1 = _co.mergeStream; _ck(_v, 22, 0, currVal_1); var currVal_2 = _co.forkJoinStream; _ck(_v, 27, 0, currVal_2); }, function (_ck, _v) { var _co = _v.component; var currVal_3 = _co.flatMappedStreams.msg; _ck(_v, 33, 0, currVal_3); }); }\nfunction View_RxJsStreams_Host_0(_l) { return core[\"_37\" /* vid */](0, [(_l()(), core[\"_15\" /* eld */](0, 0, null, null, 1, \"rxjs-streams\", [], null, null, null, View_RxJsStreams_0, RenderType_RxJsStreams)), core[\"_14\" /* did */](1, 49152, null, 0, rxjs_streams_RxJsStreams, [], null, null)], null, null); }\nvar RxJsStreamsNgFactory = core[\"_11\" /* ccf */](\"rxjs-streams\", rxjs_streams_RxJsStreams, View_RxJsStreams_Host_0, {}, {}, []);\n\n\n// EXTERNAL MODULE: ./node_modules/@angular/router/esm5/router.js\nvar router = __webpack_require__(17);\n\n// CONCATENATED MODULE: ./app-lazy/lazy-modules/rxjs-streams.module.ngfactory.js\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RxJsStreamsModuleNgFactory\", function() { return RxJsStreamsModuleNgFactory; });\n\n\n\n\n\n\nvar RxJsStreamsModuleNgFactory = core[\"_12\" /* cmf */](RxJsStreamsModule, [], function (_l) { return core[\"_26\" /* mod */]([core[\"_27\" /* mpd */](512, core[\"k\" /* ComponentFactoryResolver */], core[\"_8\" /* CodegenComponentFactoryResolver */], [[8, [RxJsStreamsNgFactory]], [3, core[\"k\" /* ComponentFactoryResolver */]], core[\"E\" /* NgModuleRef */]]), core[\"_27\" /* mpd */](4608, common[\"m\" /* NgLocalization */], common[\"l\" /* NgLocaleLocalization */], [core[\"A\" /* LOCALE_ID */], [2, common[\"t\" /* a */]]]), core[\"_27\" /* mpd */](512, common[\"c\" /* CommonModule */], common[\"c\" /* CommonModule */], []), core[\"_27\" /* mpd */](512, router[\"m\" /* RouterModule */], router[\"m\" /* RouterModule */], [[2, router[\"r\" /* a */]], [2, router[\"k\" /* Router */]]]), core[\"_27\" /* mpd */](512, RxJsStreamsModule, RxJsStreamsModule, []), core[\"_27\" /* mpd */](1024, router[\"i\" /* ROUTES */], function () { return [[{ path: \"\", component: rxjs_streams_RxJsStreams }]]; }, [])]); });\n\n\n\n/***/ }),\n\n/***/ 93:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(1);\nvar map_1 = __webpack_require__(35);\nObservable_1.Observable.prototype.map = map_1.map;\n//# sourceMappingURL=map.js.map\n\n/***/ }),\n\n/***/ 94:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar ForkJoinObservable_1 = __webpack_require__(95);\nexports.forkJoin = ForkJoinObservable_1.ForkJoinObservable.create;\n//# sourceMappingURL=forkJoin.js.map\n\n/***/ }),\n\n/***/ 95:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = __webpack_require__(1);\nvar EmptyObservable_1 = __webpack_require__(8);\nvar isArray_1 = __webpack_require__(18);\nvar subscribeToResult_1 = __webpack_require__(19);\nvar OuterSubscriber_1 = __webpack_require__(20);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar ForkJoinObservable = (function (_super) {\n    __extends(ForkJoinObservable, _super);\n    function ForkJoinObservable(sources, resultSelector) {\n        _super.call(this);\n        this.sources = sources;\n        this.resultSelector = resultSelector;\n    }\n    /* tslint:enable:max-line-length */\n    /**\n     * Joins last values emitted by passed Observables.\n     *\n     * <span class=\"informal\">Wait for Observables to complete and then combine last values they emitted.</span>\n     *\n     * <img src=\"./img/forkJoin.png\" width=\"100%\">\n     *\n     * `forkJoin` is an operator that takes any number of Observables which can be passed either as an array\n     * or directly as arguments. If no input Observables are provided, resulting stream will complete\n     * immediately.\n     *\n     * `forkJoin` will wait for all passed Observables to complete and then it will emit an array with last\n     * values from corresponding Observables. So if you pass `n` Observables to the operator, resulting\n     * array will have `n` values, where first value is the last thing emitted by the first Observable,\n     * second value is the last thing emitted by the second Observable and so on. That means `forkJoin` will\n     * not emit more than once and it will complete after that. If you need to emit combined values not only\n     * at the end of lifecycle of passed Observables, but also throughout it, try out {@link combineLatest}\n     * or {@link zip} instead.\n     *\n     * In order for resulting array to have the same length as the number of input Observables, whenever any of\n     * that Observables completes without emitting any value, `forkJoin` will complete at that moment as well\n     * and it will not emit anything either, even if it already has some last values from other Observables.\n     * Conversely, if there is an Observable that never completes, `forkJoin` will never complete as well,\n     * unless at any point some other Observable completes without emitting value, which brings us back to\n     * the previous case. Overall, in order for `forkJoin` to emit a value, all Observables passed as arguments\n     * have to emit something at least once and complete.\n     *\n     * If any input Observable errors at some point, `forkJoin` will error as well and all other Observables\n     * will be immediately unsubscribed.\n     *\n     * Optionally `forkJoin` accepts project function, that will be called with values which normally\n     * would land in emitted array. Whatever is returned by project function, will appear in output\n     * Observable instead. This means that default project can be thought of as a function that takes\n     * all its arguments and puts them into an array. Note that project function will be called only\n     * when output Observable is supposed to emit a result.\n     *\n     * @example <caption>Use forkJoin with operator emitting immediately</caption>\n     * const observable = Rx.Observable.forkJoin(\n     *   Rx.Observable.of(1, 2, 3, 4),\n     *   Rx.Observable.of(5, 6, 7, 8)\n     * );\n     * observable.subscribe(\n     *   value => console.log(value),\n     *   err => {},\n     *   () => console.log('This is how it ends!')\n     * );\n     *\n     * // Logs:\n     * // [4, 8]\n     * // \"This is how it ends!\"\n     *\n     *\n     * @example <caption>Use forkJoin with operator emitting after some time</caption>\n     * const observable = Rx.Observable.forkJoin(\n     *   Rx.Observable.interval(1000).take(3), // emit 0, 1, 2 every second and complete\n     *   Rx.Observable.interval(500).take(4) // emit 0, 1, 2, 3 every half a second and complete\n     * );\n     * observable.subscribe(\n     *   value => console.log(value),\n     *   err => {},\n     *   () => console.log('This is how it ends!')\n     * );\n     *\n     * // Logs:\n     * // [2, 3] after 3 seconds\n     * // \"This is how it ends!\" immediately after\n     *\n     *\n     * @example <caption>Use forkJoin with project function</caption>\n     * const observable = Rx.Observable.forkJoin(\n     *   Rx.Observable.interval(1000).take(3), // emit 0, 1, 2 every second and complete\n     *   Rx.Observable.interval(500).take(4), // emit 0, 1, 2, 3 every half a second and complete\n     *   (n, m) => n + m\n     * );\n     * observable.subscribe(\n     *   value => console.log(value),\n     *   err => {},\n     *   () => console.log('This is how it ends!')\n     * );\n     *\n     * // Logs:\n     * // 5 after 3 seconds\n     * // \"This is how it ends!\" immediately after\n     *\n     * @see {@link combineLatest}\n     * @see {@link zip}\n     *\n     * @param {...SubscribableOrPromise} sources Any number of Observables provided either as an array or as an arguments\n     * passed directly to the operator.\n     * @param {function} [project] Function that takes values emitted by input Observables and returns value\n     * that will appear in resulting Observable instead of default array.\n     * @return {Observable} Observable emitting either an array of last values emitted by passed Observables\n     * or value from project function.\n     * @static true\n     * @name forkJoin\n     * @owner Observable\n     */\n    ForkJoinObservable.create = function () {\n        var sources = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            sources[_i - 0] = arguments[_i];\n        }\n        if (sources === null || arguments.length === 0) {\n            return new EmptyObservable_1.EmptyObservable();\n        }\n        var resultSelector = null;\n        if (typeof sources[sources.length - 1] === 'function') {\n            resultSelector = sources.pop();\n        }\n        // if the first and only other argument besides the resultSelector is an array\n        // assume it's been called with `forkJoin([obs1, obs2, obs3], resultSelector)`\n        if (sources.length === 1 && isArray_1.isArray(sources[0])) {\n            sources = sources[0];\n        }\n        if (sources.length === 0) {\n            return new EmptyObservable_1.EmptyObservable();\n        }\n        return new ForkJoinObservable(sources, resultSelector);\n    };\n    ForkJoinObservable.prototype._subscribe = function (subscriber) {\n        return new ForkJoinSubscriber(subscriber, this.sources, this.resultSelector);\n    };\n    return ForkJoinObservable;\n}(Observable_1.Observable));\nexports.ForkJoinObservable = ForkJoinObservable;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ForkJoinSubscriber = (function (_super) {\n    __extends(ForkJoinSubscriber, _super);\n    function ForkJoinSubscriber(destination, sources, resultSelector) {\n        _super.call(this, destination);\n        this.sources = sources;\n        this.resultSelector = resultSelector;\n        this.completed = 0;\n        this.haveValues = 0;\n        var len = sources.length;\n        this.total = len;\n        this.values = new Array(len);\n        for (var i = 0; i < len; i++) {\n            var source = sources[i];\n            var innerSubscription = subscribeToResult_1.subscribeToResult(this, source, null, i);\n            if (innerSubscription) {\n                innerSubscription.outerIndex = i;\n                this.add(innerSubscription);\n            }\n        }\n    }\n    ForkJoinSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.values[outerIndex] = innerValue;\n        if (!innerSub._hasValue) {\n            innerSub._hasValue = true;\n            this.haveValues++;\n        }\n    };\n    ForkJoinSubscriber.prototype.notifyComplete = function (innerSub) {\n        var destination = this.destination;\n        var _a = this, haveValues = _a.haveValues, resultSelector = _a.resultSelector, values = _a.values;\n        var len = values.length;\n        if (!innerSub._hasValue) {\n            destination.complete();\n            return;\n        }\n        this.completed++;\n        if (this.completed !== len) {\n            return;\n        }\n        if (haveValues === len) {\n            var value = resultSelector ? resultSelector.apply(this, values) : values;\n            destination.next(value);\n        }\n        destination.complete();\n    };\n    return ForkJoinSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=ForkJoinObservable.js.map\n\n/***/ }),\n\n/***/ 97:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(1);\nvar mergeMap_1 = __webpack_require__(39);\nObservable_1.Observable.prototype.mergeMap = mergeMap_1.mergeMap;\nObservable_1.Observable.prototype.flatMap = mergeMap_1.mergeMap;\n//# sourceMappingURL=mergeMap.js.map\n\n/***/ }),\n\n/***/ 98:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(1);\nvar merge_1 = __webpack_require__(99);\nObservable_1.Observable.prototype.merge = merge_1.merge;\n//# sourceMappingURL=merge.js.map\n\n/***/ }),\n\n/***/ 99:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar merge_1 = __webpack_require__(100);\nvar merge_2 = __webpack_require__(36);\nexports.mergeStatic = merge_2.merge;\n/* tslint:enable:max-line-length */\n/**\n * Creates an output Observable which concurrently emits all values from every\n * given input Observable.\n *\n * <span class=\"informal\">Flattens multiple Observables together by blending\n * their values into one Observable.</span>\n *\n * <img src=\"./img/merge.png\" width=\"100%\">\n *\n * `merge` subscribes to each given input Observable (either the source or an\n * Observable given as argument), and simply forwards (without doing any\n * transformation) all the values from all the input Observables to the output\n * Observable. The output Observable only completes once all input Observables\n * have completed. Any error delivered by an input Observable will be immediately\n * emitted on the output Observable.\n *\n * @example <caption>Merge together two Observables: 1s interval and clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var timer = Rx.Observable.interval(1000);\n * var clicksOrTimer = clicks.merge(timer);\n * clicksOrTimer.subscribe(x => console.log(x));\n *\n * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var concurrent = 2; // the argument\n * var merged = timer1.merge(timer2, timer3, concurrent);\n * merged.subscribe(x => console.log(x));\n *\n * @see {@link mergeAll}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n *\n * @param {ObservableInput} other An input Observable to merge with the source\n * Observable. More than one input Observables may be given as argument.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @param {Scheduler} [scheduler=null] The IScheduler to use for managing\n * concurrency of input Observables.\n * @return {Observable} An Observable that emits items that are the result of\n * every input Observable.\n * @method merge\n * @owner Observable\n */\nfunction merge() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    return merge_1.merge.apply(void 0, observables)(this);\n}\nexports.merge = merge;\n//# sourceMappingURL=merge.js.map\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// 0.dist/bundle-webpack-lazy-loading.js","\"use strict\";\nvar merge_1 = require('../observable/merge');\nvar merge_2 = require('../observable/merge');\nexports.mergeStatic = merge_2.merge;\n/* tslint:enable:max-line-length */\n/**\n * Creates an output Observable which concurrently emits all values from every\n * given input Observable.\n *\n * <span class=\"informal\">Flattens multiple Observables together by blending\n * their values into one Observable.</span>\n *\n * <img src=\"./img/merge.png\" width=\"100%\">\n *\n * `merge` subscribes to each given input Observable (either the source or an\n * Observable given as argument), and simply forwards (without doing any\n * transformation) all the values from all the input Observables to the output\n * Observable. The output Observable only completes once all input Observables\n * have completed. Any error delivered by an input Observable will be immediately\n * emitted on the output Observable.\n *\n * @example <caption>Merge together two Observables: 1s interval and clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var timer = Rx.Observable.interval(1000);\n * var clicksOrTimer = clicks.merge(timer);\n * clicksOrTimer.subscribe(x => console.log(x));\n *\n * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var concurrent = 2; // the argument\n * var merged = timer1.merge(timer2, timer3, concurrent);\n * merged.subscribe(x => console.log(x));\n *\n * @see {@link mergeAll}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n *\n * @param {ObservableInput} other An input Observable to merge with the source\n * Observable. More than one input Observables may be given as argument.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @param {Scheduler} [scheduler=null] The IScheduler to use for managing\n * concurrency of input Observables.\n * @return {Observable} An Observable that emits items that are the result of\n * every input Observable.\n * @method merge\n * @owner Observable\n */\nfunction merge() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    return function (source) { return source.lift.call(merge_1.merge.apply(void 0, [source].concat(observables))); };\n}\nexports.merge = merge;\n//# sourceMappingURL=merge.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/merge.js\n// module id = 100\n// module chunks = 0 1","\"use strict\";\nvar isScheduler_1 = require('../util/isScheduler');\nvar of_1 = require('./of');\nvar from_1 = require('./from');\nvar concatAll_1 = require('../operators/concatAll');\n/* tslint:enable:max-line-length */\n/**\n * Creates an output Observable which sequentially emits all values from given\n * Observable and then moves on to the next.\n *\n * <span class=\"informal\">Concatenates multiple Observables together by\n * sequentially emitting their values, one Observable after the other.</span>\n *\n * <img src=\"./img/concat.png\" width=\"100%\">\n *\n * `concat` joins multiple Observables together, by subscribing to them one at a time and\n * merging their results into the output Observable. You can pass either an array of\n * Observables, or put them directly as arguments. Passing an empty array will result\n * in Observable that completes immediately.\n *\n * `concat` will subscribe to first input Observable and emit all its values, without\n * changing or affecting them in any way. When that Observable completes, it will\n * subscribe to then next Observable passed and, again, emit its values. This will be\n * repeated, until the operator runs out of Observables. When last input Observable completes,\n * `concat` will complete as well. At any given moment only one Observable passed to operator\n * emits values. If you would like to emit values from passed Observables concurrently, check out\n * {@link merge} instead, especially with optional `concurrent` parameter. As a matter of fact,\n * `concat` is an equivalent of `merge` operator with `concurrent` parameter set to `1`.\n *\n * Note that if some input Observable never completes, `concat` will also never complete\n * and Observables following the one that did not complete will never be subscribed. On the other\n * hand, if some Observable simply completes immediately after it is subscribed, it will be\n * invisible for `concat`, which will just move on to the next Observable.\n *\n * If any Observable in chain errors, instead of passing control to the next Observable,\n * `concat` will error immediately as well. Observables that would be subscribed after\n * the one that emitted error, never will.\n *\n * If you pass to `concat` the same Observable many times, its stream of values\n * will be \"replayed\" on every subscription, which means you can repeat given Observable\n * as many times as you like. If passing the same Observable to `concat` 1000 times becomes tedious,\n * you can always use {@link repeat}.\n *\n * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>\n * var timer = Rx.Observable.interval(1000).take(4);\n * var sequence = Rx.Observable.range(1, 10);\n * var result = Rx.Observable.concat(timer, sequence);\n * result.subscribe(x => console.log(x));\n *\n * // results in:\n * // 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10\n *\n *\n * @example <caption>Concatenate an array of 3 Observables</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var result = Rx.Observable.concat([timer1, timer2, timer3]); // note that array is passed\n * result.subscribe(x => console.log(x));\n *\n * // results in the following:\n * // (Prints to console sequentially)\n * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9\n * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5\n * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9\n *\n *\n * @example <caption>Concatenate the same Observable to repeat it</caption>\n * const timer = Rx.Observable.interval(1000).take(2);\n *\n * Rx.Observable.concat(timer, timer) // concating the same Observable!\n * .subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('...and it is done!')\n * );\n *\n * // Logs:\n * // 0 after 1s\n * // 1 after 2s\n * // 0 after 3s\n * // 1 after 4s\n * // \"...and it is done!\" also after 4s\n *\n * @see {@link concatAll}\n * @see {@link concatMap}\n * @see {@link concatMapTo}\n *\n * @param {ObservableInput} input1 An input Observable to concatenate with others.\n * @param {ObservableInput} input2 An input Observable to concatenate with others.\n * More than one input Observables may be given as argument.\n * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each\n * Observable subscription on.\n * @return {Observable} All values of each passed Observable merged into a\n * single Observable, in order, in serial fashion.\n * @static true\n * @name concat\n * @owner Observable\n */\nfunction concat() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    if (observables.length === 1 || (observables.length === 2 && isScheduler_1.isScheduler(observables[1]))) {\n        return from_1.from(observables[0]);\n    }\n    return concatAll_1.concatAll()(of_1.of.apply(void 0, observables));\n}\nexports.concat = concat;\n//# sourceMappingURL=concat.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/observable/concat.js\n// module id = 101\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar timer_1 = require('../../observable/timer');\nObservable_1.Observable.timer = timer_1.timer;\n//# sourceMappingURL=timer.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/add/observable/timer.js\n// module id = 108\n// module chunks = 0","\"use strict\";\nvar TimerObservable_1 = require('./TimerObservable');\nexports.timer = TimerObservable_1.TimerObservable.create;\n//# sourceMappingURL=timer.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/observable/timer.js\n// module id = 109\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar isNumeric_1 = require('../util/isNumeric');\nvar Observable_1 = require('../Observable');\nvar async_1 = require('../scheduler/async');\nvar isScheduler_1 = require('../util/isScheduler');\nvar isDate_1 = require('../util/isDate');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar TimerObservable = (function (_super) {\n    __extends(TimerObservable, _super);\n    function TimerObservable(dueTime, period, scheduler) {\n        if (dueTime === void 0) { dueTime = 0; }\n        _super.call(this);\n        this.period = -1;\n        this.dueTime = 0;\n        if (isNumeric_1.isNumeric(period)) {\n            this.period = Number(period) < 1 && 1 || Number(period);\n        }\n        else if (isScheduler_1.isScheduler(period)) {\n            scheduler = period;\n        }\n        if (!isScheduler_1.isScheduler(scheduler)) {\n            scheduler = async_1.async;\n        }\n        this.scheduler = scheduler;\n        this.dueTime = isDate_1.isDate(dueTime) ?\n            (+dueTime - this.scheduler.now()) :\n            dueTime;\n    }\n    /**\n     * Creates an Observable that starts emitting after an `initialDelay` and\n     * emits ever increasing numbers after each `period` of time thereafter.\n     *\n     * <span class=\"informal\">Its like {@link interval}, but you can specify when\n     * should the emissions start.</span>\n     *\n     * <img src=\"./img/timer.png\" width=\"100%\">\n     *\n     * `timer` returns an Observable that emits an infinite sequence of ascending\n     * integers, with a constant interval of time, `period` of your choosing\n     * between those emissions. The first emission happens after the specified\n     * `initialDelay`. The initial delay may be a {@link Date}. By default, this\n     * operator uses the `async` IScheduler to provide a notion of time, but you\n     * may pass any IScheduler to it. If `period` is not specified, the output\n     * Observable emits only one value, `0`. Otherwise, it emits an infinite\n     * sequence.\n     *\n     * @example <caption>Emits ascending numbers, one every second (1000ms), starting after 3 seconds</caption>\n     * var numbers = Rx.Observable.timer(3000, 1000);\n     * numbers.subscribe(x => console.log(x));\n     *\n     * @example <caption>Emits one number after five seconds</caption>\n     * var numbers = Rx.Observable.timer(5000);\n     * numbers.subscribe(x => console.log(x));\n     *\n     * @see {@link interval}\n     * @see {@link delay}\n     *\n     * @param {number|Date} initialDelay The initial delay time to wait before\n     * emitting the first value of `0`.\n     * @param {number} [period] The period of time between emissions of the\n     * subsequent numbers.\n     * @param {Scheduler} [scheduler=async] The IScheduler to use for scheduling\n     * the emission of values, and providing a notion of \"time\".\n     * @return {Observable} An Observable that emits a `0` after the\n     * `initialDelay` and ever increasing numbers after each `period` of time\n     * thereafter.\n     * @static true\n     * @name timer\n     * @owner Observable\n     */\n    TimerObservable.create = function (initialDelay, period, scheduler) {\n        if (initialDelay === void 0) { initialDelay = 0; }\n        return new TimerObservable(initialDelay, period, scheduler);\n    };\n    TimerObservable.dispatch = function (state) {\n        var index = state.index, period = state.period, subscriber = state.subscriber;\n        var action = this;\n        subscriber.next(index);\n        if (subscriber.closed) {\n            return;\n        }\n        else if (period === -1) {\n            return subscriber.complete();\n        }\n        state.index = index + 1;\n        action.schedule(state, period);\n    };\n    TimerObservable.prototype._subscribe = function (subscriber) {\n        var index = 0;\n        var _a = this, period = _a.period, dueTime = _a.dueTime, scheduler = _a.scheduler;\n        return scheduler.schedule(TimerObservable.dispatch, dueTime, {\n            index: index, period: period, subscriber: subscriber\n        });\n    };\n    return TimerObservable;\n}(Observable_1.Observable));\nexports.TimerObservable = TimerObservable;\n//# sourceMappingURL=TimerObservable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/observable/TimerObservable.js\n// module id = 110\n// module chunks = 0","\"use strict\";\nvar isArray_1 = require('../util/isArray');\nfunction isNumeric(val) {\n    // parseFloat NaNs numeric-cast false positives (null|true|false|\"\")\n    // ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n    // subtraction forces infinities to NaN\n    // adding 1 corrects loss of precision from parseFloat (#15100)\n    return !isArray_1.isArray(val) && (val - parseFloat(val) + 1) >= 0;\n}\nexports.isNumeric = isNumeric;\n;\n//# sourceMappingURL=isNumeric.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/util/isNumeric.js\n// module id = 111\n// module chunks = 0","\"use strict\";\nvar AsyncAction_1 = require('./AsyncAction');\nvar AsyncScheduler_1 = require('./AsyncScheduler');\n/**\n *\n * Async Scheduler\n *\n * <span class=\"informal\">Schedule task as if you used setTimeout(task, duration)</span>\n *\n * `async` scheduler schedules tasks asynchronously, by putting them on the JavaScript\n * event loop queue. It is best used to delay tasks in time or to schedule tasks repeating\n * in intervals.\n *\n * If you just want to \"defer\" task, that is to perform it right after currently\n * executing synchronous code ends (commonly achieved by `setTimeout(deferredTask, 0)`),\n * better choice will be the {@link asap} scheduler.\n *\n * @example <caption>Use async scheduler to delay task</caption>\n * const task = () => console.log('it works!');\n *\n * Rx.Scheduler.async.schedule(task, 2000);\n *\n * // After 2 seconds logs:\n * // \"it works!\"\n *\n *\n * @example <caption>Use async scheduler to repeat task in intervals</caption>\n * function task(state) {\n *   console.log(state);\n *   this.schedule(state + 1, 1000); // `this` references currently executing Action,\n *                                   // which we reschedule with new state and delay\n * }\n *\n * Rx.Scheduler.async.schedule(task, 3000, 0);\n *\n * // Logs:\n * // 0 after 3s\n * // 1 after 4s\n * // 2 after 5s\n * // 3 after 6s\n *\n * @static true\n * @name async\n * @owner Scheduler\n */\nexports.async = new AsyncScheduler_1.AsyncScheduler(AsyncAction_1.AsyncAction);\n//# sourceMappingURL=async.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/scheduler/async.js\n// module id = 112\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar root_1 = require('../util/root');\nvar Action_1 = require('./Action');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar AsyncAction = (function (_super) {\n    __extends(AsyncAction, _super);\n    function AsyncAction(scheduler, work) {\n        _super.call(this, scheduler, work);\n        this.scheduler = scheduler;\n        this.work = work;\n        this.pending = false;\n    }\n    AsyncAction.prototype.schedule = function (state, delay) {\n        if (delay === void 0) { delay = 0; }\n        if (this.closed) {\n            return this;\n        }\n        // Always replace the current state with the new state.\n        this.state = state;\n        // Set the pending flag indicating that this action has been scheduled, or\n        // has recursively rescheduled itself.\n        this.pending = true;\n        var id = this.id;\n        var scheduler = this.scheduler;\n        //\n        // Important implementation note:\n        //\n        // Actions only execute once by default, unless rescheduled from within the\n        // scheduled callback. This allows us to implement single and repeat\n        // actions via the same code path, without adding API surface area, as well\n        // as mimic traditional recursion but across asynchronous boundaries.\n        //\n        // However, JS runtimes and timers distinguish between intervals achieved by\n        // serial `setTimeout` calls vs. a single `setInterval` call. An interval of\n        // serial `setTimeout` calls can be individually delayed, which delays\n        // scheduling the next `setTimeout`, and so on. `setInterval` attempts to\n        // guarantee the interval callback will be invoked more precisely to the\n        // interval period, regardless of load.\n        //\n        // Therefore, we use `setInterval` to schedule single and repeat actions.\n        // If the action reschedules itself with the same delay, the interval is not\n        // canceled. If the action doesn't reschedule, or reschedules with a\n        // different delay, the interval will be canceled after scheduled callback\n        // execution.\n        //\n        if (id != null) {\n            this.id = this.recycleAsyncId(scheduler, id, delay);\n        }\n        this.delay = delay;\n        // If this action has already an async Id, don't request a new one.\n        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);\n        return this;\n    };\n    AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) { delay = 0; }\n        return root_1.root.setInterval(scheduler.flush.bind(scheduler, this), delay);\n    };\n    AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) { delay = 0; }\n        // If this action is rescheduled with the same delay time, don't clear the interval id.\n        if (delay !== null && this.delay === delay && this.pending === false) {\n            return id;\n        }\n        // Otherwise, if the action's delay time is different from the current delay,\n        // or the action has been rescheduled before it's executed, clear the interval id\n        return root_1.root.clearInterval(id) && undefined || undefined;\n    };\n    /**\n     * Immediately executes this action and the `work` it contains.\n     * @return {any}\n     */\n    AsyncAction.prototype.execute = function (state, delay) {\n        if (this.closed) {\n            return new Error('executing a cancelled action');\n        }\n        this.pending = false;\n        var error = this._execute(state, delay);\n        if (error) {\n            return error;\n        }\n        else if (this.pending === false && this.id != null) {\n            // Dequeue if the action didn't reschedule itself. Don't call\n            // unsubscribe(), because the action could reschedule later.\n            // For example:\n            // ```\n            // scheduler.schedule(function doWork(counter) {\n            //   /* ... I'm a busy worker bee ... */\n            //   var originalAction = this;\n            //   /* wait 100ms before rescheduling the action */\n            //   setTimeout(function () {\n            //     originalAction.schedule(counter + 1);\n            //   }, 100);\n            // }, 1000);\n            // ```\n            this.id = this.recycleAsyncId(this.scheduler, this.id, null);\n        }\n    };\n    AsyncAction.prototype._execute = function (state, delay) {\n        var errored = false;\n        var errorValue = undefined;\n        try {\n            this.work(state);\n        }\n        catch (e) {\n            errored = true;\n            errorValue = !!e && e || new Error(e);\n        }\n        if (errored) {\n            this.unsubscribe();\n            return errorValue;\n        }\n    };\n    AsyncAction.prototype._unsubscribe = function () {\n        var id = this.id;\n        var scheduler = this.scheduler;\n        var actions = scheduler.actions;\n        var index = actions.indexOf(this);\n        this.work = null;\n        this.state = null;\n        this.pending = false;\n        this.scheduler = null;\n        if (index !== -1) {\n            actions.splice(index, 1);\n        }\n        if (id != null) {\n            this.id = this.recycleAsyncId(scheduler, id, null);\n        }\n        this.delay = null;\n    };\n    return AsyncAction;\n}(Action_1.Action));\nexports.AsyncAction = AsyncAction;\n//# sourceMappingURL=AsyncAction.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/scheduler/AsyncAction.js\n// module id = 113\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscription_1 = require('../Subscription');\n/**\n * A unit of work to be executed in a {@link Scheduler}. An action is typically\n * created from within a Scheduler and an RxJS user does not need to concern\n * themselves about creating and manipulating an Action.\n *\n * ```ts\n * class Action<T> extends Subscription {\n *   new (scheduler: Scheduler, work: (state?: T) => void);\n *   schedule(state?: T, delay: number = 0): Subscription;\n * }\n * ```\n *\n * @class Action<T>\n */\nvar Action = (function (_super) {\n    __extends(Action, _super);\n    function Action(scheduler, work) {\n        _super.call(this);\n    }\n    /**\n     * Schedules this action on its parent Scheduler for execution. May be passed\n     * some context object, `state`. May happen at some point in the future,\n     * according to the `delay` parameter, if specified.\n     * @param {T} [state] Some contextual data that the `work` function uses when\n     * called by the Scheduler.\n     * @param {number} [delay] Time to wait before executing the work, where the\n     * time unit is implicit and defined by the Scheduler.\n     * @return {void}\n     */\n    Action.prototype.schedule = function (state, delay) {\n        if (delay === void 0) { delay = 0; }\n        return this;\n    };\n    return Action;\n}(Subscription_1.Subscription));\nexports.Action = Action;\n//# sourceMappingURL=Action.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/scheduler/Action.js\n// module id = 114\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Scheduler_1 = require('../Scheduler');\nvar AsyncScheduler = (function (_super) {\n    __extends(AsyncScheduler, _super);\n    function AsyncScheduler() {\n        _super.apply(this, arguments);\n        this.actions = [];\n        /**\n         * A flag to indicate whether the Scheduler is currently executing a batch of\n         * queued actions.\n         * @type {boolean}\n         */\n        this.active = false;\n        /**\n         * An internal ID used to track the latest asynchronous task such as those\n         * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and\n         * others.\n         * @type {any}\n         */\n        this.scheduled = undefined;\n    }\n    AsyncScheduler.prototype.flush = function (action) {\n        var actions = this.actions;\n        if (this.active) {\n            actions.push(action);\n            return;\n        }\n        var error;\n        this.active = true;\n        do {\n            if (error = action.execute(action.state, action.delay)) {\n                break;\n            }\n        } while (action = actions.shift()); // exhaust the scheduler queue\n        this.active = false;\n        if (error) {\n            while (action = actions.shift()) {\n                action.unsubscribe();\n            }\n            throw error;\n        }\n    };\n    return AsyncScheduler;\n}(Scheduler_1.Scheduler));\nexports.AsyncScheduler = AsyncScheduler;\n//# sourceMappingURL=AsyncScheduler.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/scheduler/AsyncScheduler.js\n// module id = 115\n// module chunks = 0","\"use strict\";\n/**\n * An execution context and a data structure to order tasks and schedule their\n * execution. Provides a notion of (potentially virtual) time, through the\n * `now()` getter method.\n *\n * Each unit of work in a Scheduler is called an {@link Action}.\n *\n * ```ts\n * class Scheduler {\n *   now(): number;\n *   schedule(work, delay?, state?): Subscription;\n * }\n * ```\n *\n * @class Scheduler\n */\nvar Scheduler = (function () {\n    function Scheduler(SchedulerAction, now) {\n        if (now === void 0) { now = Scheduler.now; }\n        this.SchedulerAction = SchedulerAction;\n        this.now = now;\n    }\n    /**\n     * Schedules a function, `work`, for execution. May happen at some point in\n     * the future, according to the `delay` parameter, if specified. May be passed\n     * some context object, `state`, which will be passed to the `work` function.\n     *\n     * The given arguments will be processed an stored as an Action object in a\n     * queue of actions.\n     *\n     * @param {function(state: ?T): ?Subscription} work A function representing a\n     * task, or some unit of work to be executed by the Scheduler.\n     * @param {number} [delay] Time to wait before executing the work, where the\n     * time unit is implicit and defined by the Scheduler itself.\n     * @param {T} [state] Some contextual data that the `work` function uses when\n     * called by the Scheduler.\n     * @return {Subscription} A subscription in order to be able to unsubscribe\n     * the scheduled work.\n     */\n    Scheduler.prototype.schedule = function (work, delay, state) {\n        if (delay === void 0) { delay = 0; }\n        return new this.SchedulerAction(this, work).schedule(state, delay);\n    };\n    Scheduler.now = Date.now ? Date.now : function () { return +new Date(); };\n    return Scheduler;\n}());\nexports.Scheduler = Scheduler;\n//# sourceMappingURL=Scheduler.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/Scheduler.js\n// module id = 116\n// module chunks = 0","\"use strict\";\nfunction isDate(value) {\n    return value instanceof Date && !isNaN(+value);\n}\nexports.isDate = isDate;\n//# sourceMappingURL=isDate.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/util/isDate.js\n// module id = 117\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar forkJoin_1 = require('../../observable/forkJoin');\nObservable_1.Observable.forkJoin = forkJoin_1.forkJoin;\n//# sourceMappingURL=forkJoin.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/add/observable/forkJoin.js\n// module id = 118\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar of_1 = require('../../observable/of');\nObservable_1.Observable.of = of_1.of;\n//# sourceMappingURL=of.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/add/observable/of.js\n// module id = 119\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar take_1 = require('../../operator/take');\nObservable_1.Observable.prototype.take = take_1.take;\n//# sourceMappingURL=take.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/add/operator/take.js\n// module id = 120\n// module chunks = 0","\"use strict\";\nvar take_1 = require('../operators/take');\n/**\n * Emits only the first `count` values emitted by the source Observable.\n *\n * <span class=\"informal\">Takes the first `count` values from the source, then\n * completes.</span>\n *\n * <img src=\"./img/take.png\" width=\"100%\">\n *\n * `take` returns an Observable that emits only the first `count` values emitted\n * by the source Observable. If the source emits fewer than `count` values then\n * all of its values are emitted. After that, it completes, regardless if the\n * source completes.\n *\n * @example <caption>Take the first 5 seconds of an infinite 1-second interval Observable</caption>\n * var interval = Rx.Observable.interval(1000);\n * var five = interval.take(5);\n * five.subscribe(x => console.log(x));\n *\n * @see {@link takeLast}\n * @see {@link takeUntil}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @throws {ArgumentOutOfRangeError} When using `take(i)`, it delivers an\n * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.\n *\n * @param {number} count The maximum number of `next` values to emit.\n * @return {Observable<T>} An Observable that emits only the first `count`\n * values emitted by the source Observable, or all of the values from the source\n * if the source emits fewer than `count` values.\n * @method take\n * @owner Observable\n */\nfunction take(count) {\n    return take_1.take(count)(this);\n}\nexports.take = take;\n//# sourceMappingURL=take.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operator/take.js\n// module id = 121\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar ArgumentOutOfRangeError_1 = require('../util/ArgumentOutOfRangeError');\nvar EmptyObservable_1 = require('../observable/EmptyObservable');\n/**\n * Emits only the first `count` values emitted by the source Observable.\n *\n * <span class=\"informal\">Takes the first `count` values from the source, then\n * completes.</span>\n *\n * <img src=\"./img/take.png\" width=\"100%\">\n *\n * `take` returns an Observable that emits only the first `count` values emitted\n * by the source Observable. If the source emits fewer than `count` values then\n * all of its values are emitted. After that, it completes, regardless if the\n * source completes.\n *\n * @example <caption>Take the first 5 seconds of an infinite 1-second interval Observable</caption>\n * var interval = Rx.Observable.interval(1000);\n * var five = interval.take(5);\n * five.subscribe(x => console.log(x));\n *\n * @see {@link takeLast}\n * @see {@link takeUntil}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @throws {ArgumentOutOfRangeError} When using `take(i)`, it delivers an\n * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.\n *\n * @param {number} count The maximum number of `next` values to emit.\n * @return {Observable<T>} An Observable that emits only the first `count`\n * values emitted by the source Observable, or all of the values from the source\n * if the source emits fewer than `count` values.\n * @method take\n * @owner Observable\n */\nfunction take(count) {\n    return function (source) {\n        if (count === 0) {\n            return new EmptyObservable_1.EmptyObservable();\n        }\n        else {\n            return source.lift(new TakeOperator(count));\n        }\n    };\n}\nexports.take = take;\nvar TakeOperator = (function () {\n    function TakeOperator(total) {\n        this.total = total;\n        if (this.total < 0) {\n            throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;\n        }\n    }\n    TakeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new TakeSubscriber(subscriber, this.total));\n    };\n    return TakeOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar TakeSubscriber = (function (_super) {\n    __extends(TakeSubscriber, _super);\n    function TakeSubscriber(destination, total) {\n        _super.call(this, destination);\n        this.total = total;\n        this.count = 0;\n    }\n    TakeSubscriber.prototype._next = function (value) {\n        var total = this.total;\n        var count = ++this.count;\n        if (count <= total) {\n            this.destination.next(value);\n            if (count === total) {\n                this.destination.complete();\n                this.unsubscribe();\n            }\n        }\n    };\n    return TakeSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=take.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/take.js\n// module id = 122\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar concat_1 = require('../../operator/concat');\nObservable_1.Observable.prototype.concat = concat_1.concat;\n//# sourceMappingURL=concat.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/add/operator/concat.js\n// module id = 123\n// module chunks = 0","\"use strict\";\nvar concat_1 = require('../operators/concat');\nvar concat_2 = require('../observable/concat');\nexports.concatStatic = concat_2.concat;\n/* tslint:enable:max-line-length */\n/**\n * Creates an output Observable which sequentially emits all values from every\n * given input Observable after the current Observable.\n *\n * <span class=\"informal\">Concatenates multiple Observables together by\n * sequentially emitting their values, one Observable after the other.</span>\n *\n * <img src=\"./img/concat.png\" width=\"100%\">\n *\n * Joins this Observable with multiple other Observables by subscribing to them\n * one at a time, starting with the source, and merging their results into the\n * output Observable. Will wait for each Observable to complete before moving\n * on to the next.\n *\n * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>\n * var timer = Rx.Observable.interval(1000).take(4);\n * var sequence = Rx.Observable.range(1, 10);\n * var result = timer.concat(sequence);\n * result.subscribe(x => console.log(x));\n *\n * // results in:\n * // 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10\n *\n * @example <caption>Concatenate 3 Observables</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var result = timer1.concat(timer2, timer3);\n * result.subscribe(x => console.log(x));\n *\n * // results in the following:\n * // (Prints to console sequentially)\n * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9\n * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5\n * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9\n *\n * @see {@link concatAll}\n * @see {@link concatMap}\n * @see {@link concatMapTo}\n *\n * @param {ObservableInput} other An input Observable to concatenate after the source\n * Observable. More than one input Observables may be given as argument.\n * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each\n * Observable subscription on.\n * @return {Observable} All values of each passed Observable merged into a\n * single Observable, in order, in serial fashion.\n * @method concat\n * @owner Observable\n */\nfunction concat() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    return concat_1.concat.apply(void 0, observables)(this);\n}\nexports.concat = concat;\n//# sourceMappingURL=concat.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operator/concat.js\n// module id = 124\n// module chunks = 0","\"use strict\";\nvar concat_1 = require('../observable/concat');\nvar concat_2 = require('../observable/concat');\nexports.concatStatic = concat_2.concat;\n/* tslint:enable:max-line-length */\n/**\n * Creates an output Observable which sequentially emits all values from every\n * given input Observable after the current Observable.\n *\n * <span class=\"informal\">Concatenates multiple Observables together by\n * sequentially emitting their values, one Observable after the other.</span>\n *\n * <img src=\"./img/concat.png\" width=\"100%\">\n *\n * Joins this Observable with multiple other Observables by subscribing to them\n * one at a time, starting with the source, and merging their results into the\n * output Observable. Will wait for each Observable to complete before moving\n * on to the next.\n *\n * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>\n * var timer = Rx.Observable.interval(1000).take(4);\n * var sequence = Rx.Observable.range(1, 10);\n * var result = timer.concat(sequence);\n * result.subscribe(x => console.log(x));\n *\n * // results in:\n * // 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10\n *\n * @example <caption>Concatenate 3 Observables</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var result = timer1.concat(timer2, timer3);\n * result.subscribe(x => console.log(x));\n *\n * // results in the following:\n * // (Prints to console sequentially)\n * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9\n * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5\n * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9\n *\n * @see {@link concatAll}\n * @see {@link concatMap}\n * @see {@link concatMapTo}\n *\n * @param {ObservableInput} other An input Observable to concatenate after the source\n * Observable. More than one input Observables may be given as argument.\n * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each\n * Observable subscription on.\n * @return {Observable} All values of each passed Observable merged into a\n * single Observable, in order, in serial fashion.\n * @method concat\n * @owner Observable\n */\nfunction concat() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    return function (source) { return source.lift.call(concat_1.concat.apply(void 0, [source].concat(observables))); };\n}\nexports.concat = concat;\n//# sourceMappingURL=concat.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/concat.js\n// module id = 125\n// module chunks = 0","import * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common\";\nimport * as i2 from \"./rxjs-streams\";\nvar styles_RxJsStreams = [];\nvar RenderType_RxJsStreams = i0.crt({ encapsulation: 2, styles: styles_RxJsStreams, data: {} });\nexport { RenderType_RxJsStreams as RenderType_RxJsStreams };\nfunction View_RxJsStreams_1(_l) { return i0.vid(0, [(_l()(), i0.eld(0, 0, null, null, 4, \"div\", [], null, null, null, null, null)), (_l()(), i0.eld(1, 0, null, null, 3, \"div\", [[\"class\", \"floatLeft\"]], null, null, null, null, null)), i0.did(2, 278528, null, 0, i1.NgClass, [i0.IterableDiffers, i0.KeyValueDiffers, i0.ElementRef, i0.Renderer2], { klass: [0, \"klass\"], ngClass: [1, \"ngClass\"] }, null), i0.pod(3, { stream1: 0, stream2: 1 }), (_l()(), i0.ted(4, null, [\"\", \"\"]))], function (_ck, _v) { var currVal_0 = \"floatLeft\"; var currVal_1 = _ck(_v, 3, 0, (_v.context.$implicit.source === 1), (_v.context.$implicit.source === 2)); _ck(_v, 2, 0, currVal_0, currVal_1); }, function (_ck, _v) { var currVal_2 = _v.context.$implicit.value; _ck(_v, 4, 0, currVal_2); }); }\nfunction View_RxJsStreams_2(_l) { return i0.vid(0, [(_l()(), i0.eld(0, 0, null, null, 4, \"div\", [], null, null, null, null, null)), (_l()(), i0.eld(1, 0, null, null, 3, \"div\", [[\"class\", \"floatLeft\"]], null, null, null, null, null)), i0.did(2, 278528, null, 0, i1.NgClass, [i0.IterableDiffers, i0.KeyValueDiffers, i0.ElementRef, i0.Renderer2], { klass: [0, \"klass\"], ngClass: [1, \"ngClass\"] }, null), i0.pod(3, { stream1: 0, stream2: 1 }), (_l()(), i0.ted(4, null, [\"\", \"\"]))], function (_ck, _v) { var currVal_0 = \"floatLeft\"; var currVal_1 = _ck(_v, 3, 0, (_v.context.$implicit.source === 1), (_v.context.$implicit.source === 2)); _ck(_v, 2, 0, currVal_0, currVal_1); }, function (_ck, _v) { var currVal_2 = _v.context.$implicit.value; _ck(_v, 4, 0, currVal_2); }); }\nfunction View_RxJsStreams_3(_l) { return i0.vid(0, [(_l()(), i0.eld(0, 0, null, null, 4, \"div\", [], null, null, null, null, null)), (_l()(), i0.eld(1, 0, null, null, 3, \"div\", [], null, null, null, null, null)), i0.did(2, 278528, null, 0, i1.NgClass, [i0.IterableDiffers, i0.KeyValueDiffers, i0.ElementRef, i0.Renderer2], { ngClass: [0, \"ngClass\"] }, null), i0.pod(3, { stream1: 0, stream2: 1 }), (_l()(), i0.ted(4, null, [\"\", \"\"]))], function (_ck, _v) { var currVal_0 = _ck(_v, 3, 0, (_v.context.$implicit.source === 1), (_v.context.$implicit.source === 2)); _ck(_v, 2, 0, currVal_0); }, function (_ck, _v) { var currVal_1 = _v.context.$implicit.value; _ck(_v, 4, 0, currVal_1); }); }\nexport function View_RxJsStreams_0(_l) { return i0.vid(0, [(_l()(), i0.eld(0, 0, null, null, 1, \"div\", [[\"class\", \"stream1\"]], null, null, null, null, null)), (_l()(), i0.ted(-1, null, [\"Stream1\"])), (_l()(), i0.eld(2, 0, null, null, 1, \"div\", [[\"class\", \"stream2\"]], null, null, null, null, null)), (_l()(), i0.ted(-1, null, [\"Stream2\"])), (_l()(), i0.eld(4, 0, null, null, 0, \"br\", [], null, null, null, null, null)), (_l()(), i0.eld(5, 0, null, null, 1, \"button\", [], null, [[null, \"click\"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if ((\"click\" === en)) {\n        var pd_0 = (_co.mergeStreams() !== false);\n        ad = (pd_0 && ad);\n    } return ad; }, null, null)), (_l()(), i0.ted(-1, null, [\"Merge Streams\"])), (_l()(), i0.eld(7, 0, null, null, 1, \"button\", [], null, [[null, \"click\"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if ((\"click\" === en)) {\n        var pd_0 = (_co.concatStreams() !== false);\n        ad = (pd_0 && ad);\n    } return ad; }, null, null)), (_l()(), i0.ted(-1, null, [\"Concat Streams\"])), (_l()(), i0.eld(9, 0, null, null, 1, \"button\", [], null, [[null, \"click\"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if ((\"click\" === en)) {\n        var pd_0 = (_co.forkJoinStreams() !== false);\n        ad = (pd_0 && ad);\n    } return ad; }, null, null)), (_l()(), i0.ted(-1, null, [\"ForkJoin Streams\"])), (_l()(), i0.eld(11, 0, null, null, 1, \"button\", [], null, [[null, \"click\"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if ((\"click\" === en)) {\n        var pd_0 = (_co.flatMapStreams() !== false);\n        ad = (pd_0 && ad);\n    } return ad; }, null, null)), (_l()(), i0.ted(-1, null, [\"FlatMap Streams\"])), (_l()(), i0.eld(13, 0, null, null, 4, \"div\", [[\"class\", \"stream-section\"]], null, null, null, null, null)), (_l()(), i0.eld(14, 0, null, null, 1, \"h4\", [], null, null, null, null, null)), (_l()(), i0.ted(-1, null, [\"Concatenated Streams\"])), (_l()(), i0.and(16777216, null, null, 1, null, View_RxJsStreams_1)), i0.did(17, 802816, null, 0, i1.NgForOf, [i0.ViewContainerRef, i0.TemplateRef, i0.IterableDiffers], { ngForOf: [0, \"ngForOf\"] }, null), (_l()(), i0.eld(18, 0, null, null, 4, \"div\", [[\"class\", \"stream-section\"]], null, null, null, null, null)), (_l()(), i0.eld(19, 0, null, null, 1, \"h4\", [], null, null, null, null, null)), (_l()(), i0.ted(-1, null, [\"Merged Streams\"])), (_l()(), i0.and(16777216, null, null, 1, null, View_RxJsStreams_2)), i0.did(22, 802816, null, 0, i1.NgForOf, [i0.ViewContainerRef, i0.TemplateRef, i0.IterableDiffers], { ngForOf: [0, \"ngForOf\"] }, null), (_l()(), i0.eld(23, 0, null, null, 4, \"div\", [[\"class\", \"stream-section\"]], null, null, null, null, null)), (_l()(), i0.eld(24, 0, null, null, 1, \"h4\", [], null, null, null, null, null)), (_l()(), i0.ted(-1, null, [\"ForkJoined Streams\"])), (_l()(), i0.and(16777216, null, null, 1, null, View_RxJsStreams_3)), i0.did(27, 802816, null, 0, i1.NgForOf, [i0.ViewContainerRef, i0.TemplateRef, i0.IterableDiffers], { ngForOf: [0, \"ngForOf\"] }, null), (_l()(), i0.eld(28, 0, null, null, 0, \"br\", [], null, null, null, null, null)), (_l()(), i0.eld(29, 0, null, null, 4, \"div\", [], null, null, null, null, null)), (_l()(), i0.eld(30, 0, null, null, 1, \"h4\", [], null, null, null, null, null)), (_l()(), i0.ted(-1, null, [\"Flatmapped Streams\"])), (_l()(), i0.eld(32, 0, null, null, 1, \"div\", [], null, null, null, null, null)), (_l()(), i0.ted(33, null, [\"\", \"\"]))], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.concatStream; _ck(_v, 17, 0, currVal_0); var currVal_1 = _co.mergeStream; _ck(_v, 22, 0, currVal_1); var currVal_2 = _co.forkJoinStream; _ck(_v, 27, 0, currVal_2); }, function (_ck, _v) { var _co = _v.component; var currVal_3 = _co.flatMappedStreams.msg; _ck(_v, 33, 0, currVal_3); }); }\nexport function View_RxJsStreams_Host_0(_l) { return i0.vid(0, [(_l()(), i0.eld(0, 0, null, null, 1, \"rxjs-streams\", [], null, null, null, View_RxJsStreams_0, RenderType_RxJsStreams)), i0.did(1, 49152, null, 0, i2.RxJsStreams, [], null, null)], null, null); }\nvar RxJsStreamsNgFactory = i0.ccf(\"rxjs-streams\", i2.RxJsStreams, View_RxJsStreams_Host_0, {}, {}, []);\nexport { RxJsStreamsNgFactory as RxJsStreamsNgFactory };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./components/rxjs-streams/rxjs-streams.ngfactory.js\n// module id = null\n// module chunks = ","import 'rxjs/add/operator/map';\nimport 'rxjs/add/operator/mergeMap';\nvar RxJsStreamsModule = (function () {\n    function RxJsStreamsModule() {\n    }\n    return RxJsStreamsModule;\n}());\nexport { RxJsStreamsModule };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app-lazy/lazy-modules/rxjs-streams.module.ts\n// module id = null\n// module chunks = ","import { Observable } from 'rxjs/Observable';\nimport 'rxjs/add/observable/timer';\nimport 'rxjs/add/observable/forkJoin';\nimport 'rxjs/add/observable/of';\nimport 'rxjs/add/operator/take';\nimport 'rxjs/add/operator/merge';\nimport 'rxjs/add/operator/concat';\nvar RxJsStreams = (function () {\n    function RxJsStreams() {\n        this.concatStream = [];\n        this.mergeStream = [];\n        this.forkJoinStream = [];\n        this.flatMappedStreams = {};\n    }\n    RxJsStreams.prototype.flatMapStreams = function () {\n        var _this = this;\n        var first = Observable.of(10);\n        first.flatMap(function (operand1) {\n            return Observable.of(operand1 + 10);\n        })\n            .subscribe(function (res) { return _this.flatMappedStreams = { msg: '10 + 10 = ' + res }; });\n    };\n    RxJsStreams.prototype.concatStreams = function () {\n        var _this = this;\n        var first = Observable.timer(10, 500).map(function (r) {\n            return { source: 1, value: r };\n        }).take(4);\n        var second = Observable.timer(10, 500).map(function (r) {\n            return { source: 2, value: r };\n        }).take(4);\n        first.concat(second).subscribe(function (res) { return _this.concatStream.push(res); });\n    };\n    RxJsStreams.prototype.mergeStreams = function () {\n        var _this = this;\n        var first = Observable.timer(10, 500).map(function (r) {\n            return { source: 1, value: r };\n        }).take(4);\n        var second = Observable.timer(10, 500).map(function (r) {\n            return { source: 2, value: r };\n        }).take(4);\n        first.merge(second).subscribe(function (res) { return _this.mergeStream.push(res); });\n    };\n    RxJsStreams.prototype.forkJoinStreams = function () {\n        var _this = this;\n        var first = Observable.of({ source: 1, value: 1 });\n        var second = Observable.of({ source: 2, value: 1 });\n        Observable.forkJoin(first, second)\n            .subscribe(function (res) { return _this.forkJoinStream = res; });\n    };\n    return RxJsStreams;\n}());\nexport { RxJsStreams };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./components/rxjs-streams/rxjs-streams.ts\n// module id = null\n// module chunks = ","import * as i0 from \"@angular/core\";\nimport * as i1 from \"./rxjs-streams.module\";\nimport * as i2 from \"../../components/rxjs-streams/rxjs-streams.ngfactory\";\nimport * as i3 from \"@angular/common\";\nimport * as i4 from \"@angular/router\";\nimport * as i5 from \"../../components/rxjs-streams/rxjs-streams\";\nvar RxJsStreamsModuleNgFactory = i0.cmf(i1.RxJsStreamsModule, [], function (_l) { return i0.mod([i0.mpd(512, i0.ComponentFactoryResolver, i0.CodegenComponentFactoryResolver, [[8, [i2.RxJsStreamsNgFactory]], [3, i0.ComponentFactoryResolver], i0.NgModuleRef]), i0.mpd(4608, i3.NgLocalization, i3.NgLocaleLocalization, [i0.LOCALE_ID, [2, i3.a]]), i0.mpd(512, i3.CommonModule, i3.CommonModule, []), i0.mpd(512, i4.RouterModule, i4.RouterModule, [[2, i4.a], [2, i4.Router]]), i0.mpd(512, i1.RxJsStreamsModule, i1.RxJsStreamsModule, []), i0.mpd(1024, i4.ROUTES, function () { return [[{ path: \"\", component: i5.RxJsStreams }]]; }, [])]); });\nexport { RxJsStreamsModuleNgFactory as RxJsStreamsModuleNgFactory };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app-lazy/lazy-modules/rxjs-streams.module.ngfactory.js\n// module id = null\n// module chunks = ","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar map_1 = require('../../operator/map');\nObservable_1.Observable.prototype.map = map_1.map;\n//# sourceMappingURL=map.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/add/operator/map.js\n// module id = 93\n// module chunks = 0 1 3 4 8","\"use strict\";\nvar ForkJoinObservable_1 = require('./ForkJoinObservable');\nexports.forkJoin = ForkJoinObservable_1.ForkJoinObservable.create;\n//# sourceMappingURL=forkJoin.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/observable/forkJoin.js\n// module id = 94\n// module chunks = 0 3 5 6 7","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = require('../Observable');\nvar EmptyObservable_1 = require('./EmptyObservable');\nvar isArray_1 = require('../util/isArray');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\nvar OuterSubscriber_1 = require('../OuterSubscriber');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar ForkJoinObservable = (function (_super) {\n    __extends(ForkJoinObservable, _super);\n    function ForkJoinObservable(sources, resultSelector) {\n        _super.call(this);\n        this.sources = sources;\n        this.resultSelector = resultSelector;\n    }\n    /* tslint:enable:max-line-length */\n    /**\n     * Joins last values emitted by passed Observables.\n     *\n     * <span class=\"informal\">Wait for Observables to complete and then combine last values they emitted.</span>\n     *\n     * <img src=\"./img/forkJoin.png\" width=\"100%\">\n     *\n     * `forkJoin` is an operator that takes any number of Observables which can be passed either as an array\n     * or directly as arguments. If no input Observables are provided, resulting stream will complete\n     * immediately.\n     *\n     * `forkJoin` will wait for all passed Observables to complete and then it will emit an array with last\n     * values from corresponding Observables. So if you pass `n` Observables to the operator, resulting\n     * array will have `n` values, where first value is the last thing emitted by the first Observable,\n     * second value is the last thing emitted by the second Observable and so on. That means `forkJoin` will\n     * not emit more than once and it will complete after that. If you need to emit combined values not only\n     * at the end of lifecycle of passed Observables, but also throughout it, try out {@link combineLatest}\n     * or {@link zip} instead.\n     *\n     * In order for resulting array to have the same length as the number of input Observables, whenever any of\n     * that Observables completes without emitting any value, `forkJoin` will complete at that moment as well\n     * and it will not emit anything either, even if it already has some last values from other Observables.\n     * Conversely, if there is an Observable that never completes, `forkJoin` will never complete as well,\n     * unless at any point some other Observable completes without emitting value, which brings us back to\n     * the previous case. Overall, in order for `forkJoin` to emit a value, all Observables passed as arguments\n     * have to emit something at least once and complete.\n     *\n     * If any input Observable errors at some point, `forkJoin` will error as well and all other Observables\n     * will be immediately unsubscribed.\n     *\n     * Optionally `forkJoin` accepts project function, that will be called with values which normally\n     * would land in emitted array. Whatever is returned by project function, will appear in output\n     * Observable instead. This means that default project can be thought of as a function that takes\n     * all its arguments and puts them into an array. Note that project function will be called only\n     * when output Observable is supposed to emit a result.\n     *\n     * @example <caption>Use forkJoin with operator emitting immediately</caption>\n     * const observable = Rx.Observable.forkJoin(\n     *   Rx.Observable.of(1, 2, 3, 4),\n     *   Rx.Observable.of(5, 6, 7, 8)\n     * );\n     * observable.subscribe(\n     *   value => console.log(value),\n     *   err => {},\n     *   () => console.log('This is how it ends!')\n     * );\n     *\n     * // Logs:\n     * // [4, 8]\n     * // \"This is how it ends!\"\n     *\n     *\n     * @example <caption>Use forkJoin with operator emitting after some time</caption>\n     * const observable = Rx.Observable.forkJoin(\n     *   Rx.Observable.interval(1000).take(3), // emit 0, 1, 2 every second and complete\n     *   Rx.Observable.interval(500).take(4) // emit 0, 1, 2, 3 every half a second and complete\n     * );\n     * observable.subscribe(\n     *   value => console.log(value),\n     *   err => {},\n     *   () => console.log('This is how it ends!')\n     * );\n     *\n     * // Logs:\n     * // [2, 3] after 3 seconds\n     * // \"This is how it ends!\" immediately after\n     *\n     *\n     * @example <caption>Use forkJoin with project function</caption>\n     * const observable = Rx.Observable.forkJoin(\n     *   Rx.Observable.interval(1000).take(3), // emit 0, 1, 2 every second and complete\n     *   Rx.Observable.interval(500).take(4), // emit 0, 1, 2, 3 every half a second and complete\n     *   (n, m) => n + m\n     * );\n     * observable.subscribe(\n     *   value => console.log(value),\n     *   err => {},\n     *   () => console.log('This is how it ends!')\n     * );\n     *\n     * // Logs:\n     * // 5 after 3 seconds\n     * // \"This is how it ends!\" immediately after\n     *\n     * @see {@link combineLatest}\n     * @see {@link zip}\n     *\n     * @param {...SubscribableOrPromise} sources Any number of Observables provided either as an array or as an arguments\n     * passed directly to the operator.\n     * @param {function} [project] Function that takes values emitted by input Observables and returns value\n     * that will appear in resulting Observable instead of default array.\n     * @return {Observable} Observable emitting either an array of last values emitted by passed Observables\n     * or value from project function.\n     * @static true\n     * @name forkJoin\n     * @owner Observable\n     */\n    ForkJoinObservable.create = function () {\n        var sources = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            sources[_i - 0] = arguments[_i];\n        }\n        if (sources === null || arguments.length === 0) {\n            return new EmptyObservable_1.EmptyObservable();\n        }\n        var resultSelector = null;\n        if (typeof sources[sources.length - 1] === 'function') {\n            resultSelector = sources.pop();\n        }\n        // if the first and only other argument besides the resultSelector is an array\n        // assume it's been called with `forkJoin([obs1, obs2, obs3], resultSelector)`\n        if (sources.length === 1 && isArray_1.isArray(sources[0])) {\n            sources = sources[0];\n        }\n        if (sources.length === 0) {\n            return new EmptyObservable_1.EmptyObservable();\n        }\n        return new ForkJoinObservable(sources, resultSelector);\n    };\n    ForkJoinObservable.prototype._subscribe = function (subscriber) {\n        return new ForkJoinSubscriber(subscriber, this.sources, this.resultSelector);\n    };\n    return ForkJoinObservable;\n}(Observable_1.Observable));\nexports.ForkJoinObservable = ForkJoinObservable;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ForkJoinSubscriber = (function (_super) {\n    __extends(ForkJoinSubscriber, _super);\n    function ForkJoinSubscriber(destination, sources, resultSelector) {\n        _super.call(this, destination);\n        this.sources = sources;\n        this.resultSelector = resultSelector;\n        this.completed = 0;\n        this.haveValues = 0;\n        var len = sources.length;\n        this.total = len;\n        this.values = new Array(len);\n        for (var i = 0; i < len; i++) {\n            var source = sources[i];\n            var innerSubscription = subscribeToResult_1.subscribeToResult(this, source, null, i);\n            if (innerSubscription) {\n                innerSubscription.outerIndex = i;\n                this.add(innerSubscription);\n            }\n        }\n    }\n    ForkJoinSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.values[outerIndex] = innerValue;\n        if (!innerSub._hasValue) {\n            innerSub._hasValue = true;\n            this.haveValues++;\n        }\n    };\n    ForkJoinSubscriber.prototype.notifyComplete = function (innerSub) {\n        var destination = this.destination;\n        var _a = this, haveValues = _a.haveValues, resultSelector = _a.resultSelector, values = _a.values;\n        var len = values.length;\n        if (!innerSub._hasValue) {\n            destination.complete();\n            return;\n        }\n        this.completed++;\n        if (this.completed !== len) {\n            return;\n        }\n        if (haveValues === len) {\n            var value = resultSelector ? resultSelector.apply(this, values) : values;\n            destination.next(value);\n        }\n        destination.complete();\n    };\n    return ForkJoinSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=ForkJoinObservable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/observable/ForkJoinObservable.js\n// module id = 95\n// module chunks = 0 3 5 6 7","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar mergeMap_1 = require('../../operator/mergeMap');\nObservable_1.Observable.prototype.mergeMap = mergeMap_1.mergeMap;\nObservable_1.Observable.prototype.flatMap = mergeMap_1.mergeMap;\n//# sourceMappingURL=mergeMap.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/add/operator/mergeMap.js\n// module id = 97\n// module chunks = 0 1","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar merge_1 = require('../../operator/merge');\nObservable_1.Observable.prototype.merge = merge_1.merge;\n//# sourceMappingURL=merge.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/add/operator/merge.js\n// module id = 98\n// module chunks = 0 1","\"use strict\";\nvar merge_1 = require('../operators/merge');\nvar merge_2 = require('../observable/merge');\nexports.mergeStatic = merge_2.merge;\n/* tslint:enable:max-line-length */\n/**\n * Creates an output Observable which concurrently emits all values from every\n * given input Observable.\n *\n * <span class=\"informal\">Flattens multiple Observables together by blending\n * their values into one Observable.</span>\n *\n * <img src=\"./img/merge.png\" width=\"100%\">\n *\n * `merge` subscribes to each given input Observable (either the source or an\n * Observable given as argument), and simply forwards (without doing any\n * transformation) all the values from all the input Observables to the output\n * Observable. The output Observable only completes once all input Observables\n * have completed. Any error delivered by an input Observable will be immediately\n * emitted on the output Observable.\n *\n * @example <caption>Merge together two Observables: 1s interval and clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var timer = Rx.Observable.interval(1000);\n * var clicksOrTimer = clicks.merge(timer);\n * clicksOrTimer.subscribe(x => console.log(x));\n *\n * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var concurrent = 2; // the argument\n * var merged = timer1.merge(timer2, timer3, concurrent);\n * merged.subscribe(x => console.log(x));\n *\n * @see {@link mergeAll}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n *\n * @param {ObservableInput} other An input Observable to merge with the source\n * Observable. More than one input Observables may be given as argument.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @param {Scheduler} [scheduler=null] The IScheduler to use for managing\n * concurrency of input Observables.\n * @return {Observable} An Observable that emits items that are the result of\n * every input Observable.\n * @method merge\n * @owner Observable\n */\nfunction merge() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    return merge_1.merge.apply(void 0, observables)(this);\n}\nexports.merge = merge;\n//# sourceMappingURL=merge.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operator/merge.js\n// module id = 99\n// module chunks = 0 1"],"sourceRoot":""}