{"version":3,"sources":["webpack:///1.dist/bundle-webpack-lazy-loading.js","webpack:///./node_modules/rxjs/operators/merge.js","webpack:///./node_modules/rxjs/add/operator/do.js","webpack:///./node_modules/rxjs/operator/do.js","webpack:///./node_modules/rxjs/operators/tap.js","webpack:///./node_modules/rxjs/add/observable/fromEvent.js","webpack:///./node_modules/rxjs/observable/fromEvent.js","webpack:///./node_modules/rxjs/observable/FromEventObservable.js","webpack:///./node_modules/rxjs/add/operator/filter.js","webpack:///./node_modules/rxjs/add/operator/takeUntil.js","webpack:///./node_modules/rxjs/operator/takeUntil.js","webpack:///./node_modules/rxjs/operators/takeUntil.js","webpack:///./node_modules/rxjs/add/operator/repeat.js","webpack:///./node_modules/rxjs/operator/repeat.js","webpack:///./node_modules/rxjs/operators/repeat.js","webpack:///./components/text-editor/text-editor.ngfactory.js","webpack:///./app-lazy/lazy-modules/text-editor.module.ts","webpack:///./components/text-editor/key-map.ts","webpack:///./components/text-editor/character.ts","webpack:///./components/text-editor/document.ts","webpack:///./components/text-editor/text-editor.ts","webpack:///./app-lazy/lazy-modules/text-editor.module.ngfactory.js","webpack:///./node_modules/rxjs/add/operator/map.js","webpack:///./node_modules/rxjs/add/operator/mergeMap.js","webpack:///./node_modules/rxjs/add/operator/merge.js","webpack:///./node_modules/rxjs/operator/merge.js"],"names":["webpackJsonp","100","module","exports","__webpack_require__","merge","observables","_i","arguments","length","source","lift","call","merge_1","apply","concat","merge_2","mergeStatic","105","Observable_1","do_1","Observable","prototype","do","_do","106","nextOrObserver","error","complete","tap_1","tap","this","107","DoOperator","__extends","d","b","__","constructor","p","hasOwnProperty","Object","create","Subscriber_1","subscriber","subscribe","DoSubscriber","_super","destination","safeSubscriber","Subscriber","syncErrorThrowable","add","_next","value","next","syncErrorThrown","syncErrorValue","_error","err","_complete","126","fromEvent_1","fromEvent","127","FromEventObservable_1","FromEventObservable","128","isNodeStyleEventEmitter","sourceObj","addListener","removeListener","isJQueryStyleEventEmitter","on","off","isNodeList","toString","isHTMLCollection","isEventTarget","addEventListener","removeEventListener","tryCatch_1","isFunction_1","errorObject_1","Subscription_1","eventName","selector","options","target","isFunction","undefined","setupSubscription","handler","unsubscribe","i","len","source_1","source_2","TypeError","source_3","Subscription","_subscribe","args","result","tryCatch","errorObject","e","129","filter_1","filter","130","takeUntil_1","takeUntil","131","notifier","132","TakeUntilOperator","OuterSubscriber_1","subscribeToResult_1","TakeUntilSubscriber","subscribeToResult","notifyNext","outerValue","innerValue","outerIndex","innerIndex","innerSub","notifyComplete","OuterSubscriber","133","repeat_1","repeat","134","count","135","EmptyObservable_1","EmptyObservable","RepeatOperator","RepeatSubscriber","isStopped","_a","_unsubscribeAndRecycle","90","__webpack_exports__","View_TextEditor_1","_l","core","common","ngClass","currentChar","selectedChar","_ck","_v","context","$implicit","isCurrent","isSelected","View_TextEditor_0","ngForOf","component","currentDocument","characters","View_TextEditor_Host_0","RenderType_TextEditor","text_editor_TextEditor","defineProperty","TextEditorModule","KeyMap","spaceBar","enter","a","z","backSpace","zero","nine","character_Character","Character","keyCode","lineBreak","placeHolder","deleteChar","String","fromCharCode","toLowerCase","document_Document","Document","firstSelectedCharacter","push","deselectPreviousCharacter","index","indexOf","clearSelection","character","forEach","c","edit","deleteIndex","splice","placeCursor","selectCharacter","processInput","operation","TextEditor","isSuportedCharacter","getCharacterFromElement","slice","editor","children","element","ngOnInit","_this","document","getElementById","keyUp","k","which","map","mouseDown","flatMap","m","click","keyDown","preventDefault","styles_TextEditor","encapsulation","styles","data","TextEditorNgFactory","router","TextEditorModuleNgFactory","path","93","map_1","97","mergeMap_1","mergeMap","98","99"],"mappings":"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","file":"1.dist/bundle-webpack-lazy-loading.js","sourcesContent":["webpackJsonp([1],{\n\n/***/ 100:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar merge_1 = __webpack_require__(36);\nvar merge_2 = __webpack_require__(36);\nexports.mergeStatic = merge_2.merge;\n/* tslint:enable:max-line-length */\n/**\n * Creates an output Observable which concurrently emits all values from every\n * given input Observable.\n *\n * <span class=\"informal\">Flattens multiple Observables together by blending\n * their values into one Observable.</span>\n *\n * <img src=\"./img/merge.png\" width=\"100%\">\n *\n * `merge` subscribes to each given input Observable (either the source or an\n * Observable given as argument), and simply forwards (without doing any\n * transformation) all the values from all the input Observables to the output\n * Observable. The output Observable only completes once all input Observables\n * have completed. Any error delivered by an input Observable will be immediately\n * emitted on the output Observable.\n *\n * @example <caption>Merge together two Observables: 1s interval and clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var timer = Rx.Observable.interval(1000);\n * var clicksOrTimer = clicks.merge(timer);\n * clicksOrTimer.subscribe(x => console.log(x));\n *\n * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var concurrent = 2; // the argument\n * var merged = timer1.merge(timer2, timer3, concurrent);\n * merged.subscribe(x => console.log(x));\n *\n * @see {@link mergeAll}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n *\n * @param {ObservableInput} other An input Observable to merge with the source\n * Observable. More than one input Observables may be given as argument.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @param {Scheduler} [scheduler=null] The IScheduler to use for managing\n * concurrency of input Observables.\n * @return {Observable} An Observable that emits items that are the result of\n * every input Observable.\n * @method merge\n * @owner Observable\n */\nfunction merge() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    return function (source) { return source.lift.call(merge_1.merge.apply(void 0, [source].concat(observables))); };\n}\nexports.merge = merge;\n//# sourceMappingURL=merge.js.map\n\n/***/ }),\n\n/***/ 105:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(1);\nvar do_1 = __webpack_require__(106);\nObservable_1.Observable.prototype.do = do_1._do;\nObservable_1.Observable.prototype._do = do_1._do;\n//# sourceMappingURL=do.js.map\n\n/***/ }),\n\n/***/ 106:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar tap_1 = __webpack_require__(107);\n/* tslint:enable:max-line-length */\n/**\n * Perform a side effect for every emission on the source Observable, but return\n * an Observable that is identical to the source.\n *\n * <span class=\"informal\">Intercepts each emission on the source and runs a\n * function, but returns an output which is identical to the source as long as errors don't occur.</span>\n *\n * <img src=\"./img/do.png\" width=\"100%\">\n *\n * Returns a mirrored Observable of the source Observable, but modified so that\n * the provided Observer is called to perform a side effect for every value,\n * error, and completion emitted by the source. Any errors that are thrown in\n * the aforementioned Observer or handlers are safely sent down the error path\n * of the output Observable.\n *\n * This operator is useful for debugging your Observables for the correct values\n * or performing other side effects.\n *\n * Note: this is different to a `subscribe` on the Observable. If the Observable\n * returned by `do` is not subscribed, the side effects specified by the\n * Observer will never happen. `do` therefore simply spies on existing\n * execution, it does not trigger an execution to happen like `subscribe` does.\n *\n * @example <caption>Map every click to the clientX position of that click, while also logging the click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var positions = clicks\n *   .do(ev => console.log(ev))\n *   .map(ev => ev.clientX);\n * positions.subscribe(x => console.log(x));\n *\n * @see {@link map}\n * @see {@link subscribe}\n *\n * @param {Observer|function} [nextOrObserver] A normal Observer object or a\n * callback for `next`.\n * @param {function} [error] Callback for errors in the source.\n * @param {function} [complete] Callback for the completion of the source.\n * @return {Observable} An Observable identical to the source, but runs the\n * specified Observer or callback(s) for each item.\n * @method do\n * @name do\n * @owner Observable\n */\nfunction _do(nextOrObserver, error, complete) {\n    return tap_1.tap(nextOrObserver, error, complete)(this);\n}\nexports._do = _do;\n//# sourceMappingURL=do.js.map\n\n/***/ }),\n\n/***/ 107:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(0);\n/* tslint:enable:max-line-length */\n/**\n * Perform a side effect for every emission on the source Observable, but return\n * an Observable that is identical to the source.\n *\n * <span class=\"informal\">Intercepts each emission on the source and runs a\n * function, but returns an output which is identical to the source as long as errors don't occur.</span>\n *\n * <img src=\"./img/do.png\" width=\"100%\">\n *\n * Returns a mirrored Observable of the source Observable, but modified so that\n * the provided Observer is called to perform a side effect for every value,\n * error, and completion emitted by the source. Any errors that are thrown in\n * the aforementioned Observer or handlers are safely sent down the error path\n * of the output Observable.\n *\n * This operator is useful for debugging your Observables for the correct values\n * or performing other side effects.\n *\n * Note: this is different to a `subscribe` on the Observable. If the Observable\n * returned by `do` is not subscribed, the side effects specified by the\n * Observer will never happen. `do` therefore simply spies on existing\n * execution, it does not trigger an execution to happen like `subscribe` does.\n *\n * @example <caption>Map every click to the clientX position of that click, while also logging the click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var positions = clicks\n *   .do(ev => console.log(ev))\n *   .map(ev => ev.clientX);\n * positions.subscribe(x => console.log(x));\n *\n * @see {@link map}\n * @see {@link subscribe}\n *\n * @param {Observer|function} [nextOrObserver] A normal Observer object or a\n * callback for `next`.\n * @param {function} [error] Callback for errors in the source.\n * @param {function} [complete] Callback for the completion of the source.\n * @return {Observable} An Observable identical to the source, but runs the\n * specified Observer or callback(s) for each item.\n * @name tap\n */\nfunction tap(nextOrObserver, error, complete) {\n    return function tapOperatorFunction(source) {\n        return source.lift(new DoOperator(nextOrObserver, error, complete));\n    };\n}\nexports.tap = tap;\nvar DoOperator = (function () {\n    function DoOperator(nextOrObserver, error, complete) {\n        this.nextOrObserver = nextOrObserver;\n        this.error = error;\n        this.complete = complete;\n    }\n    DoOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DoSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));\n    };\n    return DoOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DoSubscriber = (function (_super) {\n    __extends(DoSubscriber, _super);\n    function DoSubscriber(destination, nextOrObserver, error, complete) {\n        _super.call(this, destination);\n        var safeSubscriber = new Subscriber_1.Subscriber(nextOrObserver, error, complete);\n        safeSubscriber.syncErrorThrowable = true;\n        this.add(safeSubscriber);\n        this.safeSubscriber = safeSubscriber;\n    }\n    DoSubscriber.prototype._next = function (value) {\n        var safeSubscriber = this.safeSubscriber;\n        safeSubscriber.next(value);\n        if (safeSubscriber.syncErrorThrown) {\n            this.destination.error(safeSubscriber.syncErrorValue);\n        }\n        else {\n            this.destination.next(value);\n        }\n    };\n    DoSubscriber.prototype._error = function (err) {\n        var safeSubscriber = this.safeSubscriber;\n        safeSubscriber.error(err);\n        if (safeSubscriber.syncErrorThrown) {\n            this.destination.error(safeSubscriber.syncErrorValue);\n        }\n        else {\n            this.destination.error(err);\n        }\n    };\n    DoSubscriber.prototype._complete = function () {\n        var safeSubscriber = this.safeSubscriber;\n        safeSubscriber.complete();\n        if (safeSubscriber.syncErrorThrown) {\n            this.destination.error(safeSubscriber.syncErrorValue);\n        }\n        else {\n            this.destination.complete();\n        }\n    };\n    return DoSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=tap.js.map\n\n/***/ }),\n\n/***/ 126:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(1);\nvar fromEvent_1 = __webpack_require__(127);\nObservable_1.Observable.fromEvent = fromEvent_1.fromEvent;\n//# sourceMappingURL=fromEvent.js.map\n\n/***/ }),\n\n/***/ 127:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar FromEventObservable_1 = __webpack_require__(128);\nexports.fromEvent = FromEventObservable_1.FromEventObservable.create;\n//# sourceMappingURL=fromEvent.js.map\n\n/***/ }),\n\n/***/ 128:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = __webpack_require__(1);\nvar tryCatch_1 = __webpack_require__(40);\nvar isFunction_1 = __webpack_require__(22);\nvar errorObject_1 = __webpack_require__(23);\nvar Subscription_1 = __webpack_require__(7);\nvar toString = Object.prototype.toString;\nfunction isNodeStyleEventEmitter(sourceObj) {\n    return !!sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';\n}\nfunction isJQueryStyleEventEmitter(sourceObj) {\n    return !!sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';\n}\nfunction isNodeList(sourceObj) {\n    return !!sourceObj && toString.call(sourceObj) === '[object NodeList]';\n}\nfunction isHTMLCollection(sourceObj) {\n    return !!sourceObj && toString.call(sourceObj) === '[object HTMLCollection]';\n}\nfunction isEventTarget(sourceObj) {\n    return !!sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar FromEventObservable = (function (_super) {\n    __extends(FromEventObservable, _super);\n    function FromEventObservable(sourceObj, eventName, selector, options) {\n        _super.call(this);\n        this.sourceObj = sourceObj;\n        this.eventName = eventName;\n        this.selector = selector;\n        this.options = options;\n    }\n    /* tslint:enable:max-line-length */\n    /**\n     * Creates an Observable that emits events of a specific type coming from the\n     * given event target.\n     *\n     * <span class=\"informal\">Creates an Observable from DOM events, or Node.js\n     * EventEmitter events or others.</span>\n     *\n     * <img src=\"./img/fromEvent.png\" width=\"100%\">\n     *\n     * `fromEvent` accepts as a first argument event target, which is an object with methods\n     * for registering event handler functions. As a second argument it takes string that indicates\n     * type of event we want to listen for. `fromEvent` supports selected types of event targets,\n     * which are described in detail below. If your event target does not match any of the ones listed,\n     * you should use {@link fromEventPattern}, which can be used on arbitrary APIs.\n     * When it comes to APIs supported by `fromEvent`, their methods for adding and removing event\n     * handler functions have different names, but they all accept a string describing event type\n     * and function itself, which will be called whenever said event happens.\n     *\n     * Every time resulting Observable is subscribed, event handler function will be registered\n     * to event target on given event type. When that event fires, value\n     * passed as a first argument to registered function will be emitted by output Observable.\n     * When Observable is unsubscribed, function will be unregistered from event target.\n     *\n     * Note that if event target calls registered function with more than one argument, second\n     * and following arguments will not appear in resulting stream. In order to get access to them,\n     * you can pass to `fromEvent` optional project function, which will be called with all arguments\n     * passed to event handler. Output Observable will then emit value returned by project function,\n     * instead of the usual value.\n     *\n     * Remember that event targets listed below are checked via duck typing. It means that\n     * no matter what kind of object you have and no matter what environment you work in,\n     * you can safely use `fromEvent` on that object if it exposes described methods (provided\n     * of course they behave as was described above). So for example if Node.js library exposes\n     * event target which has the same method names as DOM EventTarget, `fromEvent` is still\n     * a good choice.\n     *\n     * If the API you use is more callback then event handler oriented (subscribed\n     * callback function fires only once and thus there is no need to manually\n     * unregister it), you should use {@link bindCallback} or {@link bindNodeCallback}\n     * instead.\n     *\n     * `fromEvent` supports following types of event targets:\n     *\n     * **DOM EventTarget**\n     *\n     * This is an object with `addEventListener` and `removeEventListener` methods.\n     *\n     * In the browser, `addEventListener` accepts - apart from event type string and event\n     * handler function arguments - optional third parameter, which is either an object or boolean,\n     * both used for additional configuration how and when passed function will be called. When\n     * `fromEvent` is used with event target of that type, you can provide this values\n     * as third parameter as well.\n     *\n     * **Node.js EventEmitter**\n     *\n     * An object with `addListener` and `removeListener` methods.\n     *\n     * **JQuery-style event target**\n     *\n     * An object with `on` and `off` methods\n     *\n     * **DOM NodeList**\n     *\n     * List of DOM Nodes, returned for example by `document.querySelectorAll` or `Node.childNodes`.\n     *\n     * Although this collection is not event target in itself, `fromEvent` will iterate over all Nodes\n     * it contains and install event handler function in every of them. When returned Observable\n     * is unsubscribed, function will be removed from all Nodes.\n     *\n     * **DOM HtmlCollection**\n     *\n     * Just as in case of NodeList it is a collection of DOM nodes. Here as well event handler function is\n     * installed and removed in each of elements.\n     *\n     *\n     * @example <caption>Emits clicks happening on the DOM document</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * clicks.subscribe(x => console.log(x));\n     *\n     * // Results in:\n     * // MouseEvent object logged to console every time a click\n     * // occurs on the document.\n     *\n     *\n     * @example <caption>Use addEventListener with capture option</caption>\n     * var clicksInDocument = Rx.Observable.fromEvent(document, 'click', true); // note optional configuration parameter\n     *                                                                          // which will be passed to addEventListener\n     * var clicksInDiv = Rx.Observable.fromEvent(someDivInDocument, 'click');\n     *\n     * clicksInDocument.subscribe(() => console.log('document'));\n     * clicksInDiv.subscribe(() => console.log('div'));\n     *\n     * // By default events bubble UP in DOM tree, so normally\n     * // when we would click on div in document\n     * // \"div\" would be logged first and then \"document\".\n     * // Since we specified optional `capture` option, document\n     * // will catch event when it goes DOWN DOM tree, so console\n     * // will log \"document\" and then \"div\".\n     *\n     * @see {@link bindCallback}\n     * @see {@link bindNodeCallback}\n     * @see {@link fromEventPattern}\n     *\n     * @param {EventTargetLike} target The DOM EventTarget, Node.js\n     * EventEmitter, JQuery-like event target, NodeList or HTMLCollection to attach the event handler to.\n     * @param {string} eventName The event name of interest, being emitted by the\n     * `target`.\n     * @param {EventListenerOptions} [options] Options to pass through to addEventListener\n     * @param {SelectorMethodSignature<T>} [selector] An optional function to\n     * post-process results. It takes the arguments from the event handler and\n     * should return a single value.\n     * @return {Observable<T>}\n     * @static true\n     * @name fromEvent\n     * @owner Observable\n     */\n    FromEventObservable.create = function (target, eventName, options, selector) {\n        if (isFunction_1.isFunction(options)) {\n            selector = options;\n            options = undefined;\n        }\n        return new FromEventObservable(target, eventName, selector, options);\n    };\n    FromEventObservable.setupSubscription = function (sourceObj, eventName, handler, subscriber, options) {\n        var unsubscribe;\n        if (isNodeList(sourceObj) || isHTMLCollection(sourceObj)) {\n            for (var i = 0, len = sourceObj.length; i < len; i++) {\n                FromEventObservable.setupSubscription(sourceObj[i], eventName, handler, subscriber, options);\n            }\n        }\n        else if (isEventTarget(sourceObj)) {\n            var source_1 = sourceObj;\n            sourceObj.addEventListener(eventName, handler, options);\n            unsubscribe = function () { return source_1.removeEventListener(eventName, handler); };\n        }\n        else if (isJQueryStyleEventEmitter(sourceObj)) {\n            var source_2 = sourceObj;\n            sourceObj.on(eventName, handler);\n            unsubscribe = function () { return source_2.off(eventName, handler); };\n        }\n        else if (isNodeStyleEventEmitter(sourceObj)) {\n            var source_3 = sourceObj;\n            sourceObj.addListener(eventName, handler);\n            unsubscribe = function () { return source_3.removeListener(eventName, handler); };\n        }\n        else {\n            throw new TypeError('Invalid event target');\n        }\n        subscriber.add(new Subscription_1.Subscription(unsubscribe));\n    };\n    FromEventObservable.prototype._subscribe = function (subscriber) {\n        var sourceObj = this.sourceObj;\n        var eventName = this.eventName;\n        var options = this.options;\n        var selector = this.selector;\n        var handler = selector ? function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i - 0] = arguments[_i];\n            }\n            var result = tryCatch_1.tryCatch(selector).apply(void 0, args);\n            if (result === errorObject_1.errorObject) {\n                subscriber.error(errorObject_1.errorObject.e);\n            }\n            else {\n                subscriber.next(result);\n            }\n        } : function (e) { return subscriber.next(e); };\n        FromEventObservable.setupSubscription(sourceObj, eventName, handler, subscriber, options);\n    };\n    return FromEventObservable;\n}(Observable_1.Observable));\nexports.FromEventObservable = FromEventObservable;\n//# sourceMappingURL=FromEventObservable.js.map\n\n/***/ }),\n\n/***/ 129:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(1);\nvar filter_1 = __webpack_require__(44);\nObservable_1.Observable.prototype.filter = filter_1.filter;\n//# sourceMappingURL=filter.js.map\n\n/***/ }),\n\n/***/ 130:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(1);\nvar takeUntil_1 = __webpack_require__(131);\nObservable_1.Observable.prototype.takeUntil = takeUntil_1.takeUntil;\n//# sourceMappingURL=takeUntil.js.map\n\n/***/ }),\n\n/***/ 131:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar takeUntil_1 = __webpack_require__(132);\n/**\n * Emits the values emitted by the source Observable until a `notifier`\n * Observable emits a value.\n *\n * <span class=\"informal\">Lets values pass until a second Observable,\n * `notifier`, emits something. Then, it completes.</span>\n *\n * <img src=\"./img/takeUntil.png\" width=\"100%\">\n *\n * `takeUntil` subscribes and begins mirroring the source Observable. It also\n * monitors a second Observable, `notifier` that you provide. If the `notifier`\n * emits a value, the output Observable stops mirroring the source Observable\n * and completes.\n *\n * @example <caption>Tick every second until the first click happens</caption>\n * var interval = Rx.Observable.interval(1000);\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = interval.takeUntil(clicks);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link take}\n * @see {@link takeLast}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @param {Observable} notifier The Observable whose first emitted value will\n * cause the output Observable of `takeUntil` to stop emitting values from the\n * source Observable.\n * @return {Observable<T>} An Observable that emits the values from the source\n * Observable until such time as `notifier` emits its first value.\n * @method takeUntil\n * @owner Observable\n */\nfunction takeUntil(notifier) {\n    return takeUntil_1.takeUntil(notifier)(this);\n}\nexports.takeUntil = takeUntil;\n//# sourceMappingURL=takeUntil.js.map\n\n/***/ }),\n\n/***/ 132:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = __webpack_require__(20);\nvar subscribeToResult_1 = __webpack_require__(19);\n/**\n * Emits the values emitted by the source Observable until a `notifier`\n * Observable emits a value.\n *\n * <span class=\"informal\">Lets values pass until a second Observable,\n * `notifier`, emits something. Then, it completes.</span>\n *\n * <img src=\"./img/takeUntil.png\" width=\"100%\">\n *\n * `takeUntil` subscribes and begins mirroring the source Observable. It also\n * monitors a second Observable, `notifier` that you provide. If the `notifier`\n * emits a value or a complete notification, the output Observable stops\n * mirroring the source Observable and completes.\n *\n * @example <caption>Tick every second until the first click happens</caption>\n * var interval = Rx.Observable.interval(1000);\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = interval.takeUntil(clicks);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link take}\n * @see {@link takeLast}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @param {Observable} notifier The Observable whose first emitted value will\n * cause the output Observable of `takeUntil` to stop emitting values from the\n * source Observable.\n * @return {Observable<T>} An Observable that emits the values from the source\n * Observable until such time as `notifier` emits its first value.\n * @method takeUntil\n * @owner Observable\n */\nfunction takeUntil(notifier) {\n    return function (source) { return source.lift(new TakeUntilOperator(notifier)); };\n}\nexports.takeUntil = takeUntil;\nvar TakeUntilOperator = (function () {\n    function TakeUntilOperator(notifier) {\n        this.notifier = notifier;\n    }\n    TakeUntilOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new TakeUntilSubscriber(subscriber, this.notifier));\n    };\n    return TakeUntilOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar TakeUntilSubscriber = (function (_super) {\n    __extends(TakeUntilSubscriber, _super);\n    function TakeUntilSubscriber(destination, notifier) {\n        _super.call(this, destination);\n        this.notifier = notifier;\n        this.add(subscribeToResult_1.subscribeToResult(this, notifier));\n    }\n    TakeUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.complete();\n    };\n    TakeUntilSubscriber.prototype.notifyComplete = function () {\n        // noop\n    };\n    return TakeUntilSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=takeUntil.js.map\n\n/***/ }),\n\n/***/ 133:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(1);\nvar repeat_1 = __webpack_require__(134);\nObservable_1.Observable.prototype.repeat = repeat_1.repeat;\n//# sourceMappingURL=repeat.js.map\n\n/***/ }),\n\n/***/ 134:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar repeat_1 = __webpack_require__(135);\n/**\n * Returns an Observable that repeats the stream of items emitted by the source Observable at most count times.\n *\n * <img src=\"./img/repeat.png\" width=\"100%\">\n *\n * @param {number} [count] The number of times the source Observable items are repeated, a count of 0 will yield\n * an empty Observable.\n * @return {Observable} An Observable that repeats the stream of items emitted by the source Observable at most\n * count times.\n * @method repeat\n * @owner Observable\n */\nfunction repeat(count) {\n    if (count === void 0) { count = -1; }\n    return repeat_1.repeat(count)(this);\n}\nexports.repeat = repeat;\n//# sourceMappingURL=repeat.js.map\n\n/***/ }),\n\n/***/ 135:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(0);\nvar EmptyObservable_1 = __webpack_require__(8);\n/**\n * Returns an Observable that repeats the stream of items emitted by the source Observable at most count times.\n *\n * <img src=\"./img/repeat.png\" width=\"100%\">\n *\n * @param {number} [count] The number of times the source Observable items are repeated, a count of 0 will yield\n * an empty Observable.\n * @return {Observable} An Observable that repeats the stream of items emitted by the source Observable at most\n * count times.\n * @method repeat\n * @owner Observable\n */\nfunction repeat(count) {\n    if (count === void 0) { count = -1; }\n    return function (source) {\n        if (count === 0) {\n            return new EmptyObservable_1.EmptyObservable();\n        }\n        else if (count < 0) {\n            return source.lift(new RepeatOperator(-1, source));\n        }\n        else {\n            return source.lift(new RepeatOperator(count - 1, source));\n        }\n    };\n}\nexports.repeat = repeat;\nvar RepeatOperator = (function () {\n    function RepeatOperator(count, source) {\n        this.count = count;\n        this.source = source;\n    }\n    RepeatOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new RepeatSubscriber(subscriber, this.count, this.source));\n    };\n    return RepeatOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar RepeatSubscriber = (function (_super) {\n    __extends(RepeatSubscriber, _super);\n    function RepeatSubscriber(destination, count, source) {\n        _super.call(this, destination);\n        this.count = count;\n        this.source = source;\n    }\n    RepeatSubscriber.prototype.complete = function () {\n        if (!this.isStopped) {\n            var _a = this, source = _a.source, count = _a.count;\n            if (count === 0) {\n                return _super.prototype.complete.call(this);\n            }\n            else if (count > -1) {\n                this.count = count - 1;\n            }\n            source.subscribe(this._unsubscribeAndRecycle());\n        }\n    };\n    return RepeatSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=repeat.js.map\n\n/***/ }),\n\n/***/ 90:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n\n// EXTERNAL MODULE: ./node_modules/@angular/core/esm5/core.js\nvar core = __webpack_require__(3);\n\n// CONCATENATED MODULE: ./app-lazy/lazy-modules/text-editor.module.ts\nvar TextEditorModule = (function () {\n    function TextEditorModule() {\n    }\n    return TextEditorModule;\n}());\n\n\n// EXTERNAL MODULE: ./node_modules/@angular/common/esm5/common.js\nvar common = __webpack_require__(4);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/Observable.js\nvar Observable = __webpack_require__(1);\nvar Observable_default = /*#__PURE__*/__webpack_require__.n(Observable);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/add/observable/fromEvent.js\nvar fromEvent = __webpack_require__(126);\nvar fromEvent_default = /*#__PURE__*/__webpack_require__.n(fromEvent);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/add/operator/do.js\nvar operator_do = __webpack_require__(105);\nvar do_default = /*#__PURE__*/__webpack_require__.n(operator_do);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/add/operator/map.js\nvar map = __webpack_require__(93);\nvar map_default = /*#__PURE__*/__webpack_require__.n(map);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/add/operator/filter.js\nvar filter = __webpack_require__(129);\nvar filter_default = /*#__PURE__*/__webpack_require__.n(filter);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/add/operator/mergeMap.js\nvar mergeMap = __webpack_require__(97);\nvar mergeMap_default = /*#__PURE__*/__webpack_require__.n(mergeMap);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/add/operator/takeUntil.js\nvar takeUntil = __webpack_require__(130);\nvar takeUntil_default = /*#__PURE__*/__webpack_require__.n(takeUntil);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/add/operator/repeat.js\nvar repeat = __webpack_require__(133);\nvar repeat_default = /*#__PURE__*/__webpack_require__.n(repeat);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/add/operator/merge.js\nvar merge = __webpack_require__(98);\nvar merge_default = /*#__PURE__*/__webpack_require__.n(merge);\n\n// CONCATENATED MODULE: ./components/text-editor/key-map.ts\nvar KeyMap = (function () {\n    function KeyMap() {\n    }\n    KeyMap.spaceBar = 32;\n    KeyMap.enter = 13;\n    KeyMap.a = 65;\n    KeyMap.z = 90;\n    KeyMap.backSpace = 8;\n    KeyMap.zero = 48;\n    KeyMap.nine = 57;\n    return KeyMap;\n}());\n\n\n// CONCATENATED MODULE: ./components/text-editor/character.ts\n\nvar character_Character = (function () {\n    function Character(keyCode) {\n        this.isCurrent = false;\n        this.lineBreak = false;\n        this.placeHolder = false;\n        this.deleteChar = false;\n        this.isSelected = false;\n        if (keyCode === KeyMap.enter) {\n            this.value = '\\n';\n            this.lineBreak = true;\n        }\n        else if (keyCode === -1) {\n            this.value = '';\n            this.placeHolder = true;\n        }\n        else if (keyCode === KeyMap.backSpace) {\n            this.deleteChar = true;\n        }\n        else {\n            this.value = String.fromCharCode(keyCode).toLowerCase();\n        }\n    }\n    return Character;\n}());\n\n\n// CONCATENATED MODULE: ./components/text-editor/document.ts\n\nvar document_Document = (function () {\n    function Document() {\n        this.characters = [];\n        this.firstSelectedCharacter = -1;\n        this.currentChar = new character_Character(-1);\n        this.characters.push(this.currentChar);\n        this.characters[0].isCurrent = true;\n    }\n    Document.prototype.deselectPreviousCharacter = function () {\n        if (this.currentChar) {\n            var index = this.characters.indexOf(this.currentChar);\n            this.characters[index].isCurrent = false;\n        }\n    };\n    Document.prototype.clearSelection = function (e) {\n        this.firstSelectedCharacter = -1;\n        if (e) {\n            this.firstSelectedCharacter = this.characters.indexOf(e.character);\n        }\n        this.characters.forEach(function (c) { return c.isSelected = false; });\n    };\n    Document.prototype.edit = function (character, index) {\n        if (character.deleteChar) {\n            var deleteIndex = this.characters.indexOf(this.currentChar);\n            if (deleteIndex >= 1) {\n                this.characters.splice(deleteIndex, 1);\n                if (this.characters.length > 1) {\n                    this.characters[deleteIndex - 1].isCurrent = true;\n                    this.currentChar = this.characters[deleteIndex - 1];\n                }\n                else if (this.characters.length === 1) {\n                    this.characters[0].isCurrent = true;\n                    this.currentChar = this.characters[0];\n                }\n            }\n        }\n        else {\n            this.characters.splice(index, 0, character);\n            if (character.lineBreak) {\n                this.deselectPreviousCharacter();\n                var placeHolder = new character_Character(-1);\n                this.characters.splice(index + 1, 0, placeHolder);\n                this.placeCursor(placeHolder);\n            }\n            else {\n                this.placeCursor(character);\n            }\n        }\n    };\n    Document.prototype.placeCursor = function (character) {\n        this.deselectPreviousCharacter();\n        var index = this.characters.indexOf(character);\n        this.characters[index].isCurrent = true;\n        this.currentChar = character;\n    };\n    Document.prototype.selectCharacter = function (character) {\n        var index = this.characters.indexOf(character);\n        for (var i = this.firstSelectedCharacter; i <= index; i++) {\n            this.characters[i].isSelected = true;\n        }\n    };\n    Document.prototype.processInput = function (character, operation) {\n        if (operation === 'modify') {\n            var index = this.characters.indexOf(this.currentChar);\n            if (index < 0) {\n                index = this.characters.length - 1;\n            }\n            this.edit(character, index + 1);\n        }\n        if (operation === 'select') {\n            this.placeCursor(character);\n        }\n        if (operation === 'range') {\n            this.selectCharacter(character);\n        }\n    };\n    return Document;\n}());\n\n\n// CONCATENATED MODULE: ./components/text-editor/text-editor.ts\n\n\n\n\n\n\n\n\n\n\n\n\nvar text_editor_TextEditor = (function () {\n    function TextEditor() {\n        this.currentDocument = new document_Document();\n    }\n    TextEditor.prototype.isSuportedCharacter = function (keyCode) {\n        if (keyCode >= KeyMap.a && keyCode < KeyMap.z) {\n            return true;\n        }\n        if (keyCode === KeyMap.enter || keyCode === KeyMap.spaceBar || keyCode === KeyMap.backSpace) {\n            return true;\n        }\n        if (keyCode >= KeyMap.zero && keyCode <= KeyMap.nine) {\n            return true;\n        }\n        return false;\n    };\n    TextEditor.prototype.getCharacterFromElement = function (e, operation) {\n        var index = [].slice.call(this.editor.children).indexOf(e.target);\n        if (index >= 0) {\n            return { operation: operation, character: this.currentDocument.characters[index], element: e };\n        }\n        return null;\n    };\n    TextEditor.prototype.ngOnInit = function () {\n        var _this = this;\n        this.editor = document.getElementById('page');\n        this.keyUp = Observable[\"Observable\"].fromEvent(document, 'keyup')\n            .filter(function (k) { return _this.isSuportedCharacter(k.which); })\n            .map(function (k) {\n            return { operation: 'modify', character: new character_Character(k.which), element: k };\n        });\n        this.mouseDown = Observable[\"Observable\"].fromEvent(this.editor, 'mousedown')\n            .do(function (e) { return _this.currentDocument.clearSelection(_this.getCharacterFromElement(e, 'range')); })\n            .flatMap(function (m) { return Observable[\"Observable\"].fromEvent(_this.editor, 'mousemove'); })\n            .map(function (e) { return _this.getCharacterFromElement(e, 'range'); })\n            .filter(function (e) { return e !== null; })\n            .takeUntil(Observable[\"Observable\"].fromEvent(this.editor, 'mouseup')).repeat();\n        this.click = Observable[\"Observable\"].fromEvent(this.editor, 'click')\n            .map(function (e) { return _this.getCharacterFromElement(e, 'select'); })\n            .filter(function (e) { return e !== null; });\n        this.keyDown = Observable[\"Observable\"].fromEvent(document, 'keydown')\n            .filter(function (k) { return k.which === KeyMap.spaceBar || k.which === KeyMap.backSpace; })\n            .map(function (k) {\n            return { element: k };\n        });\n        this.keyUp\n            .merge(this.click)\n            .merge(this.mouseDown)\n            .merge(this.keyDown).subscribe(function (e) {\n            _this.currentDocument.processInput(e.character, e.operation);\n            e.element.preventDefault();\n        });\n    };\n    return TextEditor;\n}());\n\n\n// CONCATENATED MODULE: ./components/text-editor/text-editor.ngfactory.js\n\n\n\nvar styles_TextEditor = [];\nvar RenderType_TextEditor = core[\"_13\" /* crt */]({ encapsulation: 2, styles: styles_TextEditor, data: {} });\n\nfunction View_TextEditor_1(_l) { return core[\"_37\" /* vid */](0, [(_l()(), core[\"_15\" /* eld */](0, 0, null, null, 3, \"span\", [], null, null, null, null, null)), core[\"_14\" /* did */](1, 278528, null, 0, common[\"i\" /* NgClass */], [core[\"y\" /* IterableDiffers */], core[\"z\" /* KeyValueDiffers */], core[\"n\" /* ElementRef */], core[\"M\" /* Renderer2 */]], { ngClass: [0, \"ngClass\"] }, null), core[\"_31\" /* pod */](2, { currentChar: 0, selectedChar: 1 }), (_l()(), core[\"_35\" /* ted */](3, null, [\"\", \"\"]))], function (_ck, _v) { var currVal_0 = _ck(_v, 2, 0, _v.context.$implicit.isCurrent, _v.context.$implicit.isSelected); _ck(_v, 1, 0, currVal_0); }, function (_ck, _v) { var currVal_1 = _v.context.$implicit.value; _ck(_v, 3, 0, currVal_1); }); }\nfunction View_TextEditor_0(_l) { return core[\"_37\" /* vid */](0, [(_l()(), core[\"_15\" /* eld */](0, 0, null, null, 1, \"h1\", [], null, null, null, null, null)), (_l()(), core[\"_35\" /* ted */](-1, null, [\"Text editor based on Observables\"])), (_l()(), core[\"_15\" /* eld */](2, 0, null, null, 1, \"div\", [[\"class\", \"alert alert-success\"], [\"role\", \"alert\"]], null, null, null, null, null)), (_l()(), core[\"_35\" /* ted */](-1, null, [\" Supports typing of letters and numbers. Basic text selection and cursor placement is also supported. \"])), (_l()(), core[\"_15\" /* eld */](4, 0, null, null, 3, \"div\", [[\"class\", \"editor\"]], null, null, null, null, null)), (_l()(), core[\"_15\" /* eld */](5, 0, null, null, 2, \"div\", [[\"class\", \"page noselect\"], [\"id\", \"page\"]], null, null, null, null, null)), (_l()(), core[\"_10\" /* and */](16777216, null, null, 1, null, View_TextEditor_1)), core[\"_14\" /* did */](7, 802816, null, 0, common[\"j\" /* NgForOf */], [core[\"Y\" /* ViewContainerRef */], core[\"V\" /* TemplateRef */], core[\"y\" /* IterableDiffers */]], { ngForOf: [0, \"ngForOf\"] }, null), (_l()(), core[\"_15\" /* eld */](8, 0, null, null, 2, \"h4\", [], null, null, null, null, null)), (_l()(), core[\"_15\" /* eld */](9, 0, null, null, 1, \"a\", [[\"href\", \"http://www.syntaxsuccess.com/viewarticle/observables-in-angular-2.0\"]], null, null, null, null, null)), (_l()(), core[\"_35\" /* ted */](-1, null, [\"Read more here\"]))], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.currentDocument.characters; _ck(_v, 7, 0, currVal_0); }, null); }\nfunction View_TextEditor_Host_0(_l) { return core[\"_37\" /* vid */](0, [(_l()(), core[\"_15\" /* eld */](0, 0, null, null, 1, \"editor\", [], null, null, null, View_TextEditor_0, RenderType_TextEditor)), core[\"_14\" /* did */](1, 114688, null, 0, text_editor_TextEditor, [], null, null)], function (_ck, _v) { _ck(_v, 1, 0); }, null); }\nvar TextEditorNgFactory = core[\"_11\" /* ccf */](\"editor\", text_editor_TextEditor, View_TextEditor_Host_0, {}, {}, []);\n\n\n// EXTERNAL MODULE: ./node_modules/@angular/router/esm5/router.js\nvar router = __webpack_require__(17);\n\n// CONCATENATED MODULE: ./app-lazy/lazy-modules/text-editor.module.ngfactory.js\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TextEditorModuleNgFactory\", function() { return TextEditorModuleNgFactory; });\n\n\n\n\n\n\nvar TextEditorModuleNgFactory = core[\"_12\" /* cmf */](TextEditorModule, [], function (_l) { return core[\"_26\" /* mod */]([core[\"_27\" /* mpd */](512, core[\"k\" /* ComponentFactoryResolver */], core[\"_8\" /* CodegenComponentFactoryResolver */], [[8, [TextEditorNgFactory]], [3, core[\"k\" /* ComponentFactoryResolver */]], core[\"E\" /* NgModuleRef */]]), core[\"_27\" /* mpd */](4608, common[\"m\" /* NgLocalization */], common[\"l\" /* NgLocaleLocalization */], [core[\"A\" /* LOCALE_ID */], [2, common[\"t\" /* a */]]]), core[\"_27\" /* mpd */](512, common[\"c\" /* CommonModule */], common[\"c\" /* CommonModule */], []), core[\"_27\" /* mpd */](512, router[\"m\" /* RouterModule */], router[\"m\" /* RouterModule */], [[2, router[\"r\" /* a */]], [2, router[\"k\" /* Router */]]]), core[\"_27\" /* mpd */](512, TextEditorModule, TextEditorModule, []), core[\"_27\" /* mpd */](1024, router[\"i\" /* ROUTES */], function () { return [[{ path: \"\", component: text_editor_TextEditor }]]; }, [])]); });\n\n\n\n/***/ }),\n\n/***/ 93:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(1);\nvar map_1 = __webpack_require__(35);\nObservable_1.Observable.prototype.map = map_1.map;\n//# sourceMappingURL=map.js.map\n\n/***/ }),\n\n/***/ 97:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(1);\nvar mergeMap_1 = __webpack_require__(39);\nObservable_1.Observable.prototype.mergeMap = mergeMap_1.mergeMap;\nObservable_1.Observable.prototype.flatMap = mergeMap_1.mergeMap;\n//# sourceMappingURL=mergeMap.js.map\n\n/***/ }),\n\n/***/ 98:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Observable_1 = __webpack_require__(1);\nvar merge_1 = __webpack_require__(99);\nObservable_1.Observable.prototype.merge = merge_1.merge;\n//# sourceMappingURL=merge.js.map\n\n/***/ }),\n\n/***/ 99:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar merge_1 = __webpack_require__(100);\nvar merge_2 = __webpack_require__(36);\nexports.mergeStatic = merge_2.merge;\n/* tslint:enable:max-line-length */\n/**\n * Creates an output Observable which concurrently emits all values from every\n * given input Observable.\n *\n * <span class=\"informal\">Flattens multiple Observables together by blending\n * their values into one Observable.</span>\n *\n * <img src=\"./img/merge.png\" width=\"100%\">\n *\n * `merge` subscribes to each given input Observable (either the source or an\n * Observable given as argument), and simply forwards (without doing any\n * transformation) all the values from all the input Observables to the output\n * Observable. The output Observable only completes once all input Observables\n * have completed. Any error delivered by an input Observable will be immediately\n * emitted on the output Observable.\n *\n * @example <caption>Merge together two Observables: 1s interval and clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var timer = Rx.Observable.interval(1000);\n * var clicksOrTimer = clicks.merge(timer);\n * clicksOrTimer.subscribe(x => console.log(x));\n *\n * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var concurrent = 2; // the argument\n * var merged = timer1.merge(timer2, timer3, concurrent);\n * merged.subscribe(x => console.log(x));\n *\n * @see {@link mergeAll}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n *\n * @param {ObservableInput} other An input Observable to merge with the source\n * Observable. More than one input Observables may be given as argument.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @param {Scheduler} [scheduler=null] The IScheduler to use for managing\n * concurrency of input Observables.\n * @return {Observable} An Observable that emits items that are the result of\n * every input Observable.\n * @method merge\n * @owner Observable\n */\nfunction merge() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    return merge_1.merge.apply(void 0, observables)(this);\n}\nexports.merge = merge;\n//# sourceMappingURL=merge.js.map\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// 1.dist/bundle-webpack-lazy-loading.js","\"use strict\";\nvar merge_1 = require('../observable/merge');\nvar merge_2 = require('../observable/merge');\nexports.mergeStatic = merge_2.merge;\n/* tslint:enable:max-line-length */\n/**\n * Creates an output Observable which concurrently emits all values from every\n * given input Observable.\n *\n * <span class=\"informal\">Flattens multiple Observables together by blending\n * their values into one Observable.</span>\n *\n * <img src=\"./img/merge.png\" width=\"100%\">\n *\n * `merge` subscribes to each given input Observable (either the source or an\n * Observable given as argument), and simply forwards (without doing any\n * transformation) all the values from all the input Observables to the output\n * Observable. The output Observable only completes once all input Observables\n * have completed. Any error delivered by an input Observable will be immediately\n * emitted on the output Observable.\n *\n * @example <caption>Merge together two Observables: 1s interval and clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var timer = Rx.Observable.interval(1000);\n * var clicksOrTimer = clicks.merge(timer);\n * clicksOrTimer.subscribe(x => console.log(x));\n *\n * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var concurrent = 2; // the argument\n * var merged = timer1.merge(timer2, timer3, concurrent);\n * merged.subscribe(x => console.log(x));\n *\n * @see {@link mergeAll}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n *\n * @param {ObservableInput} other An input Observable to merge with the source\n * Observable. More than one input Observables may be given as argument.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @param {Scheduler} [scheduler=null] The IScheduler to use for managing\n * concurrency of input Observables.\n * @return {Observable} An Observable that emits items that are the result of\n * every input Observable.\n * @method merge\n * @owner Observable\n */\nfunction merge() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    return function (source) { return source.lift.call(merge_1.merge.apply(void 0, [source].concat(observables))); };\n}\nexports.merge = merge;\n//# sourceMappingURL=merge.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/merge.js\n// module id = 100\n// module chunks = 0 1","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar do_1 = require('../../operator/do');\nObservable_1.Observable.prototype.do = do_1._do;\nObservable_1.Observable.prototype._do = do_1._do;\n//# sourceMappingURL=do.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/add/operator/do.js\n// module id = 105\n// module chunks = 1 2","\"use strict\";\nvar tap_1 = require('../operators/tap');\n/* tslint:enable:max-line-length */\n/**\n * Perform a side effect for every emission on the source Observable, but return\n * an Observable that is identical to the source.\n *\n * <span class=\"informal\">Intercepts each emission on the source and runs a\n * function, but returns an output which is identical to the source as long as errors don't occur.</span>\n *\n * <img src=\"./img/do.png\" width=\"100%\">\n *\n * Returns a mirrored Observable of the source Observable, but modified so that\n * the provided Observer is called to perform a side effect for every value,\n * error, and completion emitted by the source. Any errors that are thrown in\n * the aforementioned Observer or handlers are safely sent down the error path\n * of the output Observable.\n *\n * This operator is useful for debugging your Observables for the correct values\n * or performing other side effects.\n *\n * Note: this is different to a `subscribe` on the Observable. If the Observable\n * returned by `do` is not subscribed, the side effects specified by the\n * Observer will never happen. `do` therefore simply spies on existing\n * execution, it does not trigger an execution to happen like `subscribe` does.\n *\n * @example <caption>Map every click to the clientX position of that click, while also logging the click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var positions = clicks\n *   .do(ev => console.log(ev))\n *   .map(ev => ev.clientX);\n * positions.subscribe(x => console.log(x));\n *\n * @see {@link map}\n * @see {@link subscribe}\n *\n * @param {Observer|function} [nextOrObserver] A normal Observer object or a\n * callback for `next`.\n * @param {function} [error] Callback for errors in the source.\n * @param {function} [complete] Callback for the completion of the source.\n * @return {Observable} An Observable identical to the source, but runs the\n * specified Observer or callback(s) for each item.\n * @method do\n * @name do\n * @owner Observable\n */\nfunction _do(nextOrObserver, error, complete) {\n    return tap_1.tap(nextOrObserver, error, complete)(this);\n}\nexports._do = _do;\n//# sourceMappingURL=do.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operator/do.js\n// module id = 106\n// module chunks = 1 2","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\n/* tslint:enable:max-line-length */\n/**\n * Perform a side effect for every emission on the source Observable, but return\n * an Observable that is identical to the source.\n *\n * <span class=\"informal\">Intercepts each emission on the source and runs a\n * function, but returns an output which is identical to the source as long as errors don't occur.</span>\n *\n * <img src=\"./img/do.png\" width=\"100%\">\n *\n * Returns a mirrored Observable of the source Observable, but modified so that\n * the provided Observer is called to perform a side effect for every value,\n * error, and completion emitted by the source. Any errors that are thrown in\n * the aforementioned Observer or handlers are safely sent down the error path\n * of the output Observable.\n *\n * This operator is useful for debugging your Observables for the correct values\n * or performing other side effects.\n *\n * Note: this is different to a `subscribe` on the Observable. If the Observable\n * returned by `do` is not subscribed, the side effects specified by the\n * Observer will never happen. `do` therefore simply spies on existing\n * execution, it does not trigger an execution to happen like `subscribe` does.\n *\n * @example <caption>Map every click to the clientX position of that click, while also logging the click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var positions = clicks\n *   .do(ev => console.log(ev))\n *   .map(ev => ev.clientX);\n * positions.subscribe(x => console.log(x));\n *\n * @see {@link map}\n * @see {@link subscribe}\n *\n * @param {Observer|function} [nextOrObserver] A normal Observer object or a\n * callback for `next`.\n * @param {function} [error] Callback for errors in the source.\n * @param {function} [complete] Callback for the completion of the source.\n * @return {Observable} An Observable identical to the source, but runs the\n * specified Observer or callback(s) for each item.\n * @name tap\n */\nfunction tap(nextOrObserver, error, complete) {\n    return function tapOperatorFunction(source) {\n        return source.lift(new DoOperator(nextOrObserver, error, complete));\n    };\n}\nexports.tap = tap;\nvar DoOperator = (function () {\n    function DoOperator(nextOrObserver, error, complete) {\n        this.nextOrObserver = nextOrObserver;\n        this.error = error;\n        this.complete = complete;\n    }\n    DoOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DoSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));\n    };\n    return DoOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DoSubscriber = (function (_super) {\n    __extends(DoSubscriber, _super);\n    function DoSubscriber(destination, nextOrObserver, error, complete) {\n        _super.call(this, destination);\n        var safeSubscriber = new Subscriber_1.Subscriber(nextOrObserver, error, complete);\n        safeSubscriber.syncErrorThrowable = true;\n        this.add(safeSubscriber);\n        this.safeSubscriber = safeSubscriber;\n    }\n    DoSubscriber.prototype._next = function (value) {\n        var safeSubscriber = this.safeSubscriber;\n        safeSubscriber.next(value);\n        if (safeSubscriber.syncErrorThrown) {\n            this.destination.error(safeSubscriber.syncErrorValue);\n        }\n        else {\n            this.destination.next(value);\n        }\n    };\n    DoSubscriber.prototype._error = function (err) {\n        var safeSubscriber = this.safeSubscriber;\n        safeSubscriber.error(err);\n        if (safeSubscriber.syncErrorThrown) {\n            this.destination.error(safeSubscriber.syncErrorValue);\n        }\n        else {\n            this.destination.error(err);\n        }\n    };\n    DoSubscriber.prototype._complete = function () {\n        var safeSubscriber = this.safeSubscriber;\n        safeSubscriber.complete();\n        if (safeSubscriber.syncErrorThrown) {\n            this.destination.error(safeSubscriber.syncErrorValue);\n        }\n        else {\n            this.destination.complete();\n        }\n    };\n    return DoSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=tap.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/tap.js\n// module id = 107\n// module chunks = 1 2","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar fromEvent_1 = require('../../observable/fromEvent');\nObservable_1.Observable.fromEvent = fromEvent_1.fromEvent;\n//# sourceMappingURL=fromEvent.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/add/observable/fromEvent.js\n// module id = 126\n// module chunks = 1","\"use strict\";\nvar FromEventObservable_1 = require('./FromEventObservable');\nexports.fromEvent = FromEventObservable_1.FromEventObservable.create;\n//# sourceMappingURL=fromEvent.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/observable/fromEvent.js\n// module id = 127\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = require('../Observable');\nvar tryCatch_1 = require('../util/tryCatch');\nvar isFunction_1 = require('../util/isFunction');\nvar errorObject_1 = require('../util/errorObject');\nvar Subscription_1 = require('../Subscription');\nvar toString = Object.prototype.toString;\nfunction isNodeStyleEventEmitter(sourceObj) {\n    return !!sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';\n}\nfunction isJQueryStyleEventEmitter(sourceObj) {\n    return !!sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';\n}\nfunction isNodeList(sourceObj) {\n    return !!sourceObj && toString.call(sourceObj) === '[object NodeList]';\n}\nfunction isHTMLCollection(sourceObj) {\n    return !!sourceObj && toString.call(sourceObj) === '[object HTMLCollection]';\n}\nfunction isEventTarget(sourceObj) {\n    return !!sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar FromEventObservable = (function (_super) {\n    __extends(FromEventObservable, _super);\n    function FromEventObservable(sourceObj, eventName, selector, options) {\n        _super.call(this);\n        this.sourceObj = sourceObj;\n        this.eventName = eventName;\n        this.selector = selector;\n        this.options = options;\n    }\n    /* tslint:enable:max-line-length */\n    /**\n     * Creates an Observable that emits events of a specific type coming from the\n     * given event target.\n     *\n     * <span class=\"informal\">Creates an Observable from DOM events, or Node.js\n     * EventEmitter events or others.</span>\n     *\n     * <img src=\"./img/fromEvent.png\" width=\"100%\">\n     *\n     * `fromEvent` accepts as a first argument event target, which is an object with methods\n     * for registering event handler functions. As a second argument it takes string that indicates\n     * type of event we want to listen for. `fromEvent` supports selected types of event targets,\n     * which are described in detail below. If your event target does not match any of the ones listed,\n     * you should use {@link fromEventPattern}, which can be used on arbitrary APIs.\n     * When it comes to APIs supported by `fromEvent`, their methods for adding and removing event\n     * handler functions have different names, but they all accept a string describing event type\n     * and function itself, which will be called whenever said event happens.\n     *\n     * Every time resulting Observable is subscribed, event handler function will be registered\n     * to event target on given event type. When that event fires, value\n     * passed as a first argument to registered function will be emitted by output Observable.\n     * When Observable is unsubscribed, function will be unregistered from event target.\n     *\n     * Note that if event target calls registered function with more than one argument, second\n     * and following arguments will not appear in resulting stream. In order to get access to them,\n     * you can pass to `fromEvent` optional project function, which will be called with all arguments\n     * passed to event handler. Output Observable will then emit value returned by project function,\n     * instead of the usual value.\n     *\n     * Remember that event targets listed below are checked via duck typing. It means that\n     * no matter what kind of object you have and no matter what environment you work in,\n     * you can safely use `fromEvent` on that object if it exposes described methods (provided\n     * of course they behave as was described above). So for example if Node.js library exposes\n     * event target which has the same method names as DOM EventTarget, `fromEvent` is still\n     * a good choice.\n     *\n     * If the API you use is more callback then event handler oriented (subscribed\n     * callback function fires only once and thus there is no need to manually\n     * unregister it), you should use {@link bindCallback} or {@link bindNodeCallback}\n     * instead.\n     *\n     * `fromEvent` supports following types of event targets:\n     *\n     * **DOM EventTarget**\n     *\n     * This is an object with `addEventListener` and `removeEventListener` methods.\n     *\n     * In the browser, `addEventListener` accepts - apart from event type string and event\n     * handler function arguments - optional third parameter, which is either an object or boolean,\n     * both used for additional configuration how and when passed function will be called. When\n     * `fromEvent` is used with event target of that type, you can provide this values\n     * as third parameter as well.\n     *\n     * **Node.js EventEmitter**\n     *\n     * An object with `addListener` and `removeListener` methods.\n     *\n     * **JQuery-style event target**\n     *\n     * An object with `on` and `off` methods\n     *\n     * **DOM NodeList**\n     *\n     * List of DOM Nodes, returned for example by `document.querySelectorAll` or `Node.childNodes`.\n     *\n     * Although this collection is not event target in itself, `fromEvent` will iterate over all Nodes\n     * it contains and install event handler function in every of them. When returned Observable\n     * is unsubscribed, function will be removed from all Nodes.\n     *\n     * **DOM HtmlCollection**\n     *\n     * Just as in case of NodeList it is a collection of DOM nodes. Here as well event handler function is\n     * installed and removed in each of elements.\n     *\n     *\n     * @example <caption>Emits clicks happening on the DOM document</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * clicks.subscribe(x => console.log(x));\n     *\n     * // Results in:\n     * // MouseEvent object logged to console every time a click\n     * // occurs on the document.\n     *\n     *\n     * @example <caption>Use addEventListener with capture option</caption>\n     * var clicksInDocument = Rx.Observable.fromEvent(document, 'click', true); // note optional configuration parameter\n     *                                                                          // which will be passed to addEventListener\n     * var clicksInDiv = Rx.Observable.fromEvent(someDivInDocument, 'click');\n     *\n     * clicksInDocument.subscribe(() => console.log('document'));\n     * clicksInDiv.subscribe(() => console.log('div'));\n     *\n     * // By default events bubble UP in DOM tree, so normally\n     * // when we would click on div in document\n     * // \"div\" would be logged first and then \"document\".\n     * // Since we specified optional `capture` option, document\n     * // will catch event when it goes DOWN DOM tree, so console\n     * // will log \"document\" and then \"div\".\n     *\n     * @see {@link bindCallback}\n     * @see {@link bindNodeCallback}\n     * @see {@link fromEventPattern}\n     *\n     * @param {EventTargetLike} target The DOM EventTarget, Node.js\n     * EventEmitter, JQuery-like event target, NodeList or HTMLCollection to attach the event handler to.\n     * @param {string} eventName The event name of interest, being emitted by the\n     * `target`.\n     * @param {EventListenerOptions} [options] Options to pass through to addEventListener\n     * @param {SelectorMethodSignature<T>} [selector] An optional function to\n     * post-process results. It takes the arguments from the event handler and\n     * should return a single value.\n     * @return {Observable<T>}\n     * @static true\n     * @name fromEvent\n     * @owner Observable\n     */\n    FromEventObservable.create = function (target, eventName, options, selector) {\n        if (isFunction_1.isFunction(options)) {\n            selector = options;\n            options = undefined;\n        }\n        return new FromEventObservable(target, eventName, selector, options);\n    };\n    FromEventObservable.setupSubscription = function (sourceObj, eventName, handler, subscriber, options) {\n        var unsubscribe;\n        if (isNodeList(sourceObj) || isHTMLCollection(sourceObj)) {\n            for (var i = 0, len = sourceObj.length; i < len; i++) {\n                FromEventObservable.setupSubscription(sourceObj[i], eventName, handler, subscriber, options);\n            }\n        }\n        else if (isEventTarget(sourceObj)) {\n            var source_1 = sourceObj;\n            sourceObj.addEventListener(eventName, handler, options);\n            unsubscribe = function () { return source_1.removeEventListener(eventName, handler); };\n        }\n        else if (isJQueryStyleEventEmitter(sourceObj)) {\n            var source_2 = sourceObj;\n            sourceObj.on(eventName, handler);\n            unsubscribe = function () { return source_2.off(eventName, handler); };\n        }\n        else if (isNodeStyleEventEmitter(sourceObj)) {\n            var source_3 = sourceObj;\n            sourceObj.addListener(eventName, handler);\n            unsubscribe = function () { return source_3.removeListener(eventName, handler); };\n        }\n        else {\n            throw new TypeError('Invalid event target');\n        }\n        subscriber.add(new Subscription_1.Subscription(unsubscribe));\n    };\n    FromEventObservable.prototype._subscribe = function (subscriber) {\n        var sourceObj = this.sourceObj;\n        var eventName = this.eventName;\n        var options = this.options;\n        var selector = this.selector;\n        var handler = selector ? function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i - 0] = arguments[_i];\n            }\n            var result = tryCatch_1.tryCatch(selector).apply(void 0, args);\n            if (result === errorObject_1.errorObject) {\n                subscriber.error(errorObject_1.errorObject.e);\n            }\n            else {\n                subscriber.next(result);\n            }\n        } : function (e) { return subscriber.next(e); };\n        FromEventObservable.setupSubscription(sourceObj, eventName, handler, subscriber, options);\n    };\n    return FromEventObservable;\n}(Observable_1.Observable));\nexports.FromEventObservable = FromEventObservable;\n//# sourceMappingURL=FromEventObservable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/observable/FromEventObservable.js\n// module id = 128\n// module chunks = 1","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar filter_1 = require('../../operator/filter');\nObservable_1.Observable.prototype.filter = filter_1.filter;\n//# sourceMappingURL=filter.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/add/operator/filter.js\n// module id = 129\n// module chunks = 1","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar takeUntil_1 = require('../../operator/takeUntil');\nObservable_1.Observable.prototype.takeUntil = takeUntil_1.takeUntil;\n//# sourceMappingURL=takeUntil.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/add/operator/takeUntil.js\n// module id = 130\n// module chunks = 1","\"use strict\";\nvar takeUntil_1 = require('../operators/takeUntil');\n/**\n * Emits the values emitted by the source Observable until a `notifier`\n * Observable emits a value.\n *\n * <span class=\"informal\">Lets values pass until a second Observable,\n * `notifier`, emits something. Then, it completes.</span>\n *\n * <img src=\"./img/takeUntil.png\" width=\"100%\">\n *\n * `takeUntil` subscribes and begins mirroring the source Observable. It also\n * monitors a second Observable, `notifier` that you provide. If the `notifier`\n * emits a value, the output Observable stops mirroring the source Observable\n * and completes.\n *\n * @example <caption>Tick every second until the first click happens</caption>\n * var interval = Rx.Observable.interval(1000);\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = interval.takeUntil(clicks);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link take}\n * @see {@link takeLast}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @param {Observable} notifier The Observable whose first emitted value will\n * cause the output Observable of `takeUntil` to stop emitting values from the\n * source Observable.\n * @return {Observable<T>} An Observable that emits the values from the source\n * Observable until such time as `notifier` emits its first value.\n * @method takeUntil\n * @owner Observable\n */\nfunction takeUntil(notifier) {\n    return takeUntil_1.takeUntil(notifier)(this);\n}\nexports.takeUntil = takeUntil;\n//# sourceMappingURL=takeUntil.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operator/takeUntil.js\n// module id = 131\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/**\n * Emits the values emitted by the source Observable until a `notifier`\n * Observable emits a value.\n *\n * <span class=\"informal\">Lets values pass until a second Observable,\n * `notifier`, emits something. Then, it completes.</span>\n *\n * <img src=\"./img/takeUntil.png\" width=\"100%\">\n *\n * `takeUntil` subscribes and begins mirroring the source Observable. It also\n * monitors a second Observable, `notifier` that you provide. If the `notifier`\n * emits a value or a complete notification, the output Observable stops\n * mirroring the source Observable and completes.\n *\n * @example <caption>Tick every second until the first click happens</caption>\n * var interval = Rx.Observable.interval(1000);\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = interval.takeUntil(clicks);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link take}\n * @see {@link takeLast}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @param {Observable} notifier The Observable whose first emitted value will\n * cause the output Observable of `takeUntil` to stop emitting values from the\n * source Observable.\n * @return {Observable<T>} An Observable that emits the values from the source\n * Observable until such time as `notifier` emits its first value.\n * @method takeUntil\n * @owner Observable\n */\nfunction takeUntil(notifier) {\n    return function (source) { return source.lift(new TakeUntilOperator(notifier)); };\n}\nexports.takeUntil = takeUntil;\nvar TakeUntilOperator = (function () {\n    function TakeUntilOperator(notifier) {\n        this.notifier = notifier;\n    }\n    TakeUntilOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new TakeUntilSubscriber(subscriber, this.notifier));\n    };\n    return TakeUntilOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar TakeUntilSubscriber = (function (_super) {\n    __extends(TakeUntilSubscriber, _super);\n    function TakeUntilSubscriber(destination, notifier) {\n        _super.call(this, destination);\n        this.notifier = notifier;\n        this.add(subscribeToResult_1.subscribeToResult(this, notifier));\n    }\n    TakeUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.complete();\n    };\n    TakeUntilSubscriber.prototype.notifyComplete = function () {\n        // noop\n    };\n    return TakeUntilSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=takeUntil.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/takeUntil.js\n// module id = 132\n// module chunks = 1","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar repeat_1 = require('../../operator/repeat');\nObservable_1.Observable.prototype.repeat = repeat_1.repeat;\n//# sourceMappingURL=repeat.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/add/operator/repeat.js\n// module id = 133\n// module chunks = 1","\"use strict\";\nvar repeat_1 = require('../operators/repeat');\n/**\n * Returns an Observable that repeats the stream of items emitted by the source Observable at most count times.\n *\n * <img src=\"./img/repeat.png\" width=\"100%\">\n *\n * @param {number} [count] The number of times the source Observable items are repeated, a count of 0 will yield\n * an empty Observable.\n * @return {Observable} An Observable that repeats the stream of items emitted by the source Observable at most\n * count times.\n * @method repeat\n * @owner Observable\n */\nfunction repeat(count) {\n    if (count === void 0) { count = -1; }\n    return repeat_1.repeat(count)(this);\n}\nexports.repeat = repeat;\n//# sourceMappingURL=repeat.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operator/repeat.js\n// module id = 134\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar EmptyObservable_1 = require('../observable/EmptyObservable');\n/**\n * Returns an Observable that repeats the stream of items emitted by the source Observable at most count times.\n *\n * <img src=\"./img/repeat.png\" width=\"100%\">\n *\n * @param {number} [count] The number of times the source Observable items are repeated, a count of 0 will yield\n * an empty Observable.\n * @return {Observable} An Observable that repeats the stream of items emitted by the source Observable at most\n * count times.\n * @method repeat\n * @owner Observable\n */\nfunction repeat(count) {\n    if (count === void 0) { count = -1; }\n    return function (source) {\n        if (count === 0) {\n            return new EmptyObservable_1.EmptyObservable();\n        }\n        else if (count < 0) {\n            return source.lift(new RepeatOperator(-1, source));\n        }\n        else {\n            return source.lift(new RepeatOperator(count - 1, source));\n        }\n    };\n}\nexports.repeat = repeat;\nvar RepeatOperator = (function () {\n    function RepeatOperator(count, source) {\n        this.count = count;\n        this.source = source;\n    }\n    RepeatOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new RepeatSubscriber(subscriber, this.count, this.source));\n    };\n    return RepeatOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar RepeatSubscriber = (function (_super) {\n    __extends(RepeatSubscriber, _super);\n    function RepeatSubscriber(destination, count, source) {\n        _super.call(this, destination);\n        this.count = count;\n        this.source = source;\n    }\n    RepeatSubscriber.prototype.complete = function () {\n        if (!this.isStopped) {\n            var _a = this, source = _a.source, count = _a.count;\n            if (count === 0) {\n                return _super.prototype.complete.call(this);\n            }\n            else if (count > -1) {\n                this.count = count - 1;\n            }\n            source.subscribe(this._unsubscribeAndRecycle());\n        }\n    };\n    return RepeatSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=repeat.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/repeat.js\n// module id = 135\n// module chunks = 1","import * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common\";\nimport * as i2 from \"./text-editor\";\nvar styles_TextEditor = [];\nvar RenderType_TextEditor = i0.crt({ encapsulation: 2, styles: styles_TextEditor, data: {} });\nexport { RenderType_TextEditor as RenderType_TextEditor };\nfunction View_TextEditor_1(_l) { return i0.vid(0, [(_l()(), i0.eld(0, 0, null, null, 3, \"span\", [], null, null, null, null, null)), i0.did(1, 278528, null, 0, i1.NgClass, [i0.IterableDiffers, i0.KeyValueDiffers, i0.ElementRef, i0.Renderer2], { ngClass: [0, \"ngClass\"] }, null), i0.pod(2, { currentChar: 0, selectedChar: 1 }), (_l()(), i0.ted(3, null, [\"\", \"\"]))], function (_ck, _v) { var currVal_0 = _ck(_v, 2, 0, _v.context.$implicit.isCurrent, _v.context.$implicit.isSelected); _ck(_v, 1, 0, currVal_0); }, function (_ck, _v) { var currVal_1 = _v.context.$implicit.value; _ck(_v, 3, 0, currVal_1); }); }\nexport function View_TextEditor_0(_l) { return i0.vid(0, [(_l()(), i0.eld(0, 0, null, null, 1, \"h1\", [], null, null, null, null, null)), (_l()(), i0.ted(-1, null, [\"Text editor based on Observables\"])), (_l()(), i0.eld(2, 0, null, null, 1, \"div\", [[\"class\", \"alert alert-success\"], [\"role\", \"alert\"]], null, null, null, null, null)), (_l()(), i0.ted(-1, null, [\" Supports typing of letters and numbers. Basic text selection and cursor placement is also supported. \"])), (_l()(), i0.eld(4, 0, null, null, 3, \"div\", [[\"class\", \"editor\"]], null, null, null, null, null)), (_l()(), i0.eld(5, 0, null, null, 2, \"div\", [[\"class\", \"page noselect\"], [\"id\", \"page\"]], null, null, null, null, null)), (_l()(), i0.and(16777216, null, null, 1, null, View_TextEditor_1)), i0.did(7, 802816, null, 0, i1.NgForOf, [i0.ViewContainerRef, i0.TemplateRef, i0.IterableDiffers], { ngForOf: [0, \"ngForOf\"] }, null), (_l()(), i0.eld(8, 0, null, null, 2, \"h4\", [], null, null, null, null, null)), (_l()(), i0.eld(9, 0, null, null, 1, \"a\", [[\"href\", \"http://www.syntaxsuccess.com/viewarticle/observables-in-angular-2.0\"]], null, null, null, null, null)), (_l()(), i0.ted(-1, null, [\"Read more here\"]))], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.currentDocument.characters; _ck(_v, 7, 0, currVal_0); }, null); }\nexport function View_TextEditor_Host_0(_l) { return i0.vid(0, [(_l()(), i0.eld(0, 0, null, null, 1, \"editor\", [], null, null, null, View_TextEditor_0, RenderType_TextEditor)), i0.did(1, 114688, null, 0, i2.TextEditor, [], null, null)], function (_ck, _v) { _ck(_v, 1, 0); }, null); }\nvar TextEditorNgFactory = i0.ccf(\"editor\", i2.TextEditor, View_TextEditor_Host_0, {}, {}, []);\nexport { TextEditorNgFactory as TextEditorNgFactory };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./components/text-editor/text-editor.ngfactory.js\n// module id = null\n// module chunks = ","var TextEditorModule = (function () {\n    function TextEditorModule() {\n    }\n    return TextEditorModule;\n}());\nexport { TextEditorModule };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app-lazy/lazy-modules/text-editor.module.ts\n// module id = null\n// module chunks = ","var KeyMap = (function () {\n    function KeyMap() {\n    }\n    KeyMap.spaceBar = 32;\n    KeyMap.enter = 13;\n    KeyMap.a = 65;\n    KeyMap.z = 90;\n    KeyMap.backSpace = 8;\n    KeyMap.zero = 48;\n    KeyMap.nine = 57;\n    return KeyMap;\n}());\nexport { KeyMap };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./components/text-editor/key-map.ts\n// module id = null\n// module chunks = ","import { KeyMap } from './key-map';\nvar Character = (function () {\n    function Character(keyCode) {\n        this.isCurrent = false;\n        this.lineBreak = false;\n        this.placeHolder = false;\n        this.deleteChar = false;\n        this.isSelected = false;\n        if (keyCode === KeyMap.enter) {\n            this.value = '\\n';\n            this.lineBreak = true;\n        }\n        else if (keyCode === -1) {\n            this.value = '';\n            this.placeHolder = true;\n        }\n        else if (keyCode === KeyMap.backSpace) {\n            this.deleteChar = true;\n        }\n        else {\n            this.value = String.fromCharCode(keyCode).toLowerCase();\n        }\n    }\n    return Character;\n}());\nexport { Character };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./components/text-editor/character.ts\n// module id = null\n// module chunks = ","import { Character } from './character';\nvar Document = (function () {\n    function Document() {\n        this.characters = [];\n        this.firstSelectedCharacter = -1;\n        this.currentChar = new Character(-1);\n        this.characters.push(this.currentChar);\n        this.characters[0].isCurrent = true;\n    }\n    Document.prototype.deselectPreviousCharacter = function () {\n        if (this.currentChar) {\n            var index = this.characters.indexOf(this.currentChar);\n            this.characters[index].isCurrent = false;\n        }\n    };\n    Document.prototype.clearSelection = function (e) {\n        this.firstSelectedCharacter = -1;\n        if (e) {\n            this.firstSelectedCharacter = this.characters.indexOf(e.character);\n        }\n        this.characters.forEach(function (c) { return c.isSelected = false; });\n    };\n    Document.prototype.edit = function (character, index) {\n        if (character.deleteChar) {\n            var deleteIndex = this.characters.indexOf(this.currentChar);\n            if (deleteIndex >= 1) {\n                this.characters.splice(deleteIndex, 1);\n                if (this.characters.length > 1) {\n                    this.characters[deleteIndex - 1].isCurrent = true;\n                    this.currentChar = this.characters[deleteIndex - 1];\n                }\n                else if (this.characters.length === 1) {\n                    this.characters[0].isCurrent = true;\n                    this.currentChar = this.characters[0];\n                }\n            }\n        }\n        else {\n            this.characters.splice(index, 0, character);\n            if (character.lineBreak) {\n                this.deselectPreviousCharacter();\n                var placeHolder = new Character(-1);\n                this.characters.splice(index + 1, 0, placeHolder);\n                this.placeCursor(placeHolder);\n            }\n            else {\n                this.placeCursor(character);\n            }\n        }\n    };\n    Document.prototype.placeCursor = function (character) {\n        this.deselectPreviousCharacter();\n        var index = this.characters.indexOf(character);\n        this.characters[index].isCurrent = true;\n        this.currentChar = character;\n    };\n    Document.prototype.selectCharacter = function (character) {\n        var index = this.characters.indexOf(character);\n        for (var i = this.firstSelectedCharacter; i <= index; i++) {\n            this.characters[i].isSelected = true;\n        }\n    };\n    Document.prototype.processInput = function (character, operation) {\n        if (operation === 'modify') {\n            var index = this.characters.indexOf(this.currentChar);\n            if (index < 0) {\n                index = this.characters.length - 1;\n            }\n            this.edit(character, index + 1);\n        }\n        if (operation === 'select') {\n            this.placeCursor(character);\n        }\n        if (operation === 'range') {\n            this.selectCharacter(character);\n        }\n    };\n    return Document;\n}());\nexport { Document };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./components/text-editor/document.ts\n// module id = null\n// module chunks = ","import { Observable } from 'rxjs/Observable';\nimport 'rxjs/add/observable/fromEvent';\nimport 'rxjs/add/operator/do';\nimport 'rxjs/add/operator/map';\nimport 'rxjs/add/operator/filter';\nimport 'rxjs/add/operator/mergeMap';\nimport 'rxjs/add/operator/takeUntil';\nimport 'rxjs/add/operator/repeat';\nimport 'rxjs/add/operator/merge';\nimport { Character } from './character';\nimport { Document } from './document';\nimport { KeyMap } from './key-map';\nvar TextEditor = (function () {\n    function TextEditor() {\n        this.currentDocument = new Document();\n    }\n    TextEditor.prototype.isSuportedCharacter = function (keyCode) {\n        if (keyCode >= KeyMap.a && keyCode < KeyMap.z) {\n            return true;\n        }\n        if (keyCode === KeyMap.enter || keyCode === KeyMap.spaceBar || keyCode === KeyMap.backSpace) {\n            return true;\n        }\n        if (keyCode >= KeyMap.zero && keyCode <= KeyMap.nine) {\n            return true;\n        }\n        return false;\n    };\n    TextEditor.prototype.getCharacterFromElement = function (e, operation) {\n        var index = [].slice.call(this.editor.children).indexOf(e.target);\n        if (index >= 0) {\n            return { operation: operation, character: this.currentDocument.characters[index], element: e };\n        }\n        return null;\n    };\n    TextEditor.prototype.ngOnInit = function () {\n        var _this = this;\n        this.editor = document.getElementById('page');\n        this.keyUp = Observable.fromEvent(document, 'keyup')\n            .filter(function (k) { return _this.isSuportedCharacter(k.which); })\n            .map(function (k) {\n            return { operation: 'modify', character: new Character(k.which), element: k };\n        });\n        this.mouseDown = Observable.fromEvent(this.editor, 'mousedown')\n            .do(function (e) { return _this.currentDocument.clearSelection(_this.getCharacterFromElement(e, 'range')); })\n            .flatMap(function (m) { return Observable.fromEvent(_this.editor, 'mousemove'); })\n            .map(function (e) { return _this.getCharacterFromElement(e, 'range'); })\n            .filter(function (e) { return e !== null; })\n            .takeUntil(Observable.fromEvent(this.editor, 'mouseup')).repeat();\n        this.click = Observable.fromEvent(this.editor, 'click')\n            .map(function (e) { return _this.getCharacterFromElement(e, 'select'); })\n            .filter(function (e) { return e !== null; });\n        this.keyDown = Observable.fromEvent(document, 'keydown')\n            .filter(function (k) { return k.which === KeyMap.spaceBar || k.which === KeyMap.backSpace; })\n            .map(function (k) {\n            return { element: k };\n        });\n        this.keyUp\n            .merge(this.click)\n            .merge(this.mouseDown)\n            .merge(this.keyDown).subscribe(function (e) {\n            _this.currentDocument.processInput(e.character, e.operation);\n            e.element.preventDefault();\n        });\n    };\n    return TextEditor;\n}());\nexport { TextEditor };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./components/text-editor/text-editor.ts\n// module id = null\n// module chunks = ","import * as i0 from \"@angular/core\";\nimport * as i1 from \"./text-editor.module\";\nimport * as i2 from \"../../components/text-editor/text-editor.ngfactory\";\nimport * as i3 from \"@angular/common\";\nimport * as i4 from \"@angular/router\";\nimport * as i5 from \"../../components/text-editor/text-editor\";\nvar TextEditorModuleNgFactory = i0.cmf(i1.TextEditorModule, [], function (_l) { return i0.mod([i0.mpd(512, i0.ComponentFactoryResolver, i0.CodegenComponentFactoryResolver, [[8, [i2.TextEditorNgFactory]], [3, i0.ComponentFactoryResolver], i0.NgModuleRef]), i0.mpd(4608, i3.NgLocalization, i3.NgLocaleLocalization, [i0.LOCALE_ID, [2, i3.a]]), i0.mpd(512, i3.CommonModule, i3.CommonModule, []), i0.mpd(512, i4.RouterModule, i4.RouterModule, [[2, i4.a], [2, i4.Router]]), i0.mpd(512, i1.TextEditorModule, i1.TextEditorModule, []), i0.mpd(1024, i4.ROUTES, function () { return [[{ path: \"\", component: i5.TextEditor }]]; }, [])]); });\nexport { TextEditorModuleNgFactory as TextEditorModuleNgFactory };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app-lazy/lazy-modules/text-editor.module.ngfactory.js\n// module id = null\n// module chunks = ","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar map_1 = require('../../operator/map');\nObservable_1.Observable.prototype.map = map_1.map;\n//# sourceMappingURL=map.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/add/operator/map.js\n// module id = 93\n// module chunks = 0 1 3 4 8","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar mergeMap_1 = require('../../operator/mergeMap');\nObservable_1.Observable.prototype.mergeMap = mergeMap_1.mergeMap;\nObservable_1.Observable.prototype.flatMap = mergeMap_1.mergeMap;\n//# sourceMappingURL=mergeMap.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/add/operator/mergeMap.js\n// module id = 97\n// module chunks = 0 1","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar merge_1 = require('../../operator/merge');\nObservable_1.Observable.prototype.merge = merge_1.merge;\n//# sourceMappingURL=merge.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/add/operator/merge.js\n// module id = 98\n// module chunks = 0 1","\"use strict\";\nvar merge_1 = require('../operators/merge');\nvar merge_2 = require('../observable/merge');\nexports.mergeStatic = merge_2.merge;\n/* tslint:enable:max-line-length */\n/**\n * Creates an output Observable which concurrently emits all values from every\n * given input Observable.\n *\n * <span class=\"informal\">Flattens multiple Observables together by blending\n * their values into one Observable.</span>\n *\n * <img src=\"./img/merge.png\" width=\"100%\">\n *\n * `merge` subscribes to each given input Observable (either the source or an\n * Observable given as argument), and simply forwards (without doing any\n * transformation) all the values from all the input Observables to the output\n * Observable. The output Observable only completes once all input Observables\n * have completed. Any error delivered by an input Observable will be immediately\n * emitted on the output Observable.\n *\n * @example <caption>Merge together two Observables: 1s interval and clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var timer = Rx.Observable.interval(1000);\n * var clicksOrTimer = clicks.merge(timer);\n * clicksOrTimer.subscribe(x => console.log(x));\n *\n * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var concurrent = 2; // the argument\n * var merged = timer1.merge(timer2, timer3, concurrent);\n * merged.subscribe(x => console.log(x));\n *\n * @see {@link mergeAll}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n *\n * @param {ObservableInput} other An input Observable to merge with the source\n * Observable. More than one input Observables may be given as argument.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @param {Scheduler} [scheduler=null] The IScheduler to use for managing\n * concurrency of input Observables.\n * @return {Observable} An Observable that emits items that are the result of\n * every input Observable.\n * @method merge\n * @owner Observable\n */\nfunction merge() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    return merge_1.merge.apply(void 0, observables)(this);\n}\nexports.merge = merge;\n//# sourceMappingURL=merge.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operator/merge.js\n// module id = 99\n// module chunks = 0 1"],"sourceRoot":""}